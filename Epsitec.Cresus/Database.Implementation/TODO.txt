
Questions à régler
------------------

 1.	Comment les BLOBs sont-ils gérés avec ADO.NET ?

 2.	Quel est le type retourné par DataColumn.Type quand on est sur
	une colonne de type BLOB ?

 3.	Comment des chaînes String sont-elles stockées dans la base de
	données (Firebird) si elles contiennent des caractères en dehors
	du jeu strictement 8-bit ?

 4.	En relation directe avec (3) étudier comment la directive CHARSET
	doit être initialisée avec Firebird pour pouvoir stocker les infos
	en format UTF-8.

 5. Faut-il, en particulier, utiliser System.Text.Encoding pour
    transformer les chaînes .NET en UTF-8 et vice-versa lorsque l'on
    communique avec Firebird, ou est-ce que le "provider ADO.NET"
    fait le travail à notre place ?

 6. Est-ce que le type System.DateTime peut être utilisé avec Firebird ?
    Combien de bits est-ce que cela prend ? Les données stockées dans la
    base sont-elles indépendantes du format de la date du système (un
    contre exemple serait un stockage ASCII de type jj-mm-aaaa hh:mm:ss) ?

 7. ---

 8. --- Firebird support BIGINT qui est un entier 64 bits.

 9. Implémenter TypeConverter. Cela implique en particulier d'être
    capable de transformer des données brutes manipulées par ADO.NET
    en données simplifiées. Pour les données numériques, s'appuyer entre
    autres sur la classe DbNumDef.
    
    L'idée est que les types numériques bruts (DbRawType.Int16, ...)
    sont stockés tels quels dans la base, mais que des types un peu
    plus subtils comme une valeur numérique comprise 100000..100009
    sont d'abord convertis en Int64 au moyen de DbNumDef.ConvertToInt64
    ce qui les ramène dans une plage 0..9 -> on peut utiliser des types
    de données plus petits dans la base.

10. Implémenter FirebirdTypeConverter selon ITypeConverter. En principe,
    il suffit d'appeler les méthodes correspondantes de la classe
    TypeConverter pour réaliser les conversions de base.
    
    Les types comme Guid ne sont pas supportés par Firebird, alors on
    ne tente pas de les émuler avec des CHAR(n) pour le moment... La
    classe DbColumn va partager un Guid en deux Int64.

11. Compléter les tests avec NUnit, vérifier que tout marche correcte-
	ment.

12. Tenter une implémentation minimale de, par exemple :
	
	- OleDbAbstraction
	- OleDbAbstractionFactory
	
	afin de vérifier si l'on peut accéder indifféremment à Firebird
	et à une base de données parlant OLE DB (ou autre).

13. Implémenter ce qui manque dans DbNumDef.

14. Implémenter FirebirdSqlBuilder, OleDbSqlBuilder minimal.


Implémentation (suite)
----------------------

Bien que cela puisse paraître redondant, j'ai défini des classes pour
la représentation des tables et des colonnes parallèles à ce qui existe
dans System.Data.

Contrairement à DataTable, la SqlTable n'est pas prévue pour stocker
des données, mais juste pour stocker les informations de schéma.

Les classes SqlTable et SqlColumn sont donc utilisées principalement
par ISqlBuilder, ainsi que par IDbAbstraction, pour décrire le schéma
de la base de données.


- Vérifier l'implémentation de InternalCollectionList et de ses classes
  dérivées, à savoir SqlColumnCollection, SqlFieldCollection, ...

- Ecrire les tests pour SqlTable, SqlColumn, SqlColumnCollection.

- Compléter la classe SqlField.

- Ecrire les tests pour SqlField, SqlFunction, SqlSelect, si c'est
  jugé utile. Peut-être ces classes sont-elles suffisamment simples
  pour ne pas nécessiter de tests spécifiques.


Détails au sujet de SqlSelect
-----------------------------

La commande SELECT en SQL est très riche. La classe SqlSelect tente
de représenter un sous-ensemble utile de ce que SELECT sait faire.

Un certain nombre d'informations ne sont pas stockées explicitement
par l'objet SqlSelect. En particulier :

- Lorsqu'un ou plusieurs des champs du SELECT sont de type Aggregate,
  le SELECT doit comporter une clause GROUP BY. Les champs listés par
  GROUP BY sont dérivés implicitement de la liste des champs: tous
  les champs de type non-aggrégat y figurent.

- Les informations de tri pour la clause ORDER BY sont intégrées
  directement dans les spécifications des champs, au moyen de la
  propriété SqlField.Order.

- A la place des spécifications des tables, il est bien sûr aussi
  possible de spécifier des sous-requêtes via SqlField...
  
  Note: l'alias des tables est indispensable pour spécifier les
        noms des champs du SELECT.

- On peut créer des requêtes SQL de type 'set', à savoir plusieurs
  SELECT composés au moyen de UNION, EXCEPT ou INTERSECT.
  
  Note: dans ce cas, le SqlSelectPredicate apparaît avant le deuxième
        SELECT, alors que pour le premier SELECT, il apparaît après.
        Ex.: SELECT >DISTINCT< ... UNION >DISTINCT< SELECT ...
  
  Pour créer ces requêtes, il faut utiliser SqlSelect.Add pour
  réaliser le chaînage.

- Les termes de la clause WHERE sont spécifiées en terme de SqlField,
  mais seules des fonctions ou des procédures peuvent y être utilisées
  pour l'instant.

- Les JOINs sont spécifiés indirectement au moyen des termes de la
  clause WHERE (SqlSelect.Condition), où SqlField.Type == Function
  et SqlField.AsFunction.Type == SqlFunctionType.InnerJoin. Dans un
  tel cas, les deux termes A et B de la SqlFunction doivent être
  des noms qualifiés (nom de table + nom de colonne), car ISqlBuilder
  doit être capable de retrouver le nom des tables pour construire la
  clause 'FROM Table1 JOIN Table2 ON Table1.id = Table2.id'.

- La clause GROUP BY n'est pas supportée, la clause HAVING non plus.


Détails sur ISqlBuilder.Insert/Update/RemoveData
------------------------------------------------

L'insertion de données dans une table nécessite à la fois un nom de
table et un nom de colonne par champ à écrire. Le nom de la table est
passé explicitement à l'appel ISqlBuilder.InsertData et les noms des
champs sont extraits au moyen de SqlField.Alias.

ISqlBuilder génère un objet System.Data.IDbCommand initialisé avec
tout ce qu'il faut pour pouvoir exécuter la commande (obtenir un
System.Data.IDataAdapter via IDbAbstraction.NewDataAdapter, par
exemple).

ISqlBuilder.Command doit savoir extraire les informations des
SqlFieldCollection (InsertData, UpdateData) et si besoin créer
des paramètres pour passer les données. On peut en effet imaginer
un code du genre:

	SqlFieldCollection fields = ...;
	ISqlBuilder builder = ...;
	...
	fields.Add (SqlField.CreateParameterIn (data, DbRawType.ByteArray));
	...
	builder.InsertData ("T_TABLE", fields);
	...

ISqlBuilder générera probablement :

	FbCommand command = ...;
	...
	command.Parameters.Add ("@P_1", FbType...);
	command.Parameters[0].Value = data;
	...

ISqlBuilder permet aussi de créer des appels à des procédures SQL,
mais je n'ai pas encore d'expérience dans ce domaine. Voici l'idée:

- On crée des SqlFields qui définissent les paramètres qui seront
  passés à la procédure SQL (in et out).
  
- On appelle ISqlBuilder.ExecuteProcedure pour générer le code SQL
  et l'objet System.Data.IDbCommand avec les paramètres.

- On exécute la commande, puis on demande à IDbAbstraction de nous
  extraire les paramètres retournés en sortie dans une collection
  de SqlFields. SqlField.AsParameter retourne alors la valeur...
  
  IDbAbstraction.ExtractSqlParameters va extraire les paramètres
  de retour et remplir les instances de SqlField au moyen de la
  méthode SqlField.SetParameterOutResult.


Pour l'instant, ISqlBuilder ne supporte pas d'insertion à partir de
données provenant directement d'une requête de type SELECT. Certaines
base n'aiment pas cela, et on peut s'en passer au prix d'un "hop"
supplémentaire entre la base de données et le logiciel.

ISqlBuilder ne supporte pas non plus les mises à jour de type "UPDATE
Table SET ROW = ... WHERE ...", mais uniquement la version "UPDATE Table
SET ... WHERE ...". Les conditions de mise à jour pour la clause WHERE
sont extraites d'une SqlFieldCollection; chaque SqlField référence une
fonction de comparaison (SqlFunction.Type = Compare). Tous les termes
sont unis par des AND. Si on désire faire des OR, il faut construire
soi-même l'arbre des SqlFunction.


Détails sur l'adaptation des types DbRawType
--------------------------------------------

Firebird n'a pas l'air d'implémenter des types de données correspondant
à des quantités 128-bit. Il n'est donc pas possible de réaliser un
support natif pour le type DbRawType.Guid.

Par contre, un support "synthétique" pour DbSimpleType.Guid est tout
à fait faisable, en attribuant à une colonne "synthétique" deux
colonnes natives.

Le soin de réaliser ces adaptations quand nécessaire est laissé au
projet DataLayer.
