
Questions à régler
------------------

 1.	Comment les BLOBs sont-ils gérés avec ADO.NET ?

 2.	Quel est le type retourné par DataColumn.Type quand on est sur
	une colonne de type BLOB ?

 3.	Comment des chaînes String sont-elles stockées dans la base de
	données (Firebird) si elles contiennent des caractères en dehors
	du jeu strictement 8-bit ?

 4.	En relation directe avec (3) étudier comment la directive CHARSET
	doit être initialisée avec Firebird pour pouvoir stocker les infos
	en format UTF-8.

 5. Faut-il, en particulier, utiliser System.Text.Encoding pour
    transformer les chaînes .NET en UTF-8 et vice-versa lorsque l'on
    communique avec Firebird, ou est-ce que le "provider ADO.NET"
    fait le travail à notre place ?

 6. Est-ce que le type System.DateTime peut être utilisé avec Firebird ?
    Combien de bits est-ce que cela prend ? Les données stockées dans la
    base sont-elles indépendantes du format de la date du système (un
    contre exemple serait un stockage ASCII de type jj-mm-aaaa hh:mm:ss) ?

 7. ---

 8. Quelles sont les limites sur le type System.Decimal lorsqu'il est
    utilisé avec Firebird ? Et pour System.Double ? Est-ce vraiment un
    nombre réel 64-bit ?

 9. Implémenter TypeConverter.

10. Implémenter FirebirdTypeConverter selon ITypeConverter. Utiliser
    TypeConverter.AnalyseRawType, entre autres.

11. Compléter les tests avec NUnit, vérifier que tout marche correcte-
	ment.

12. Tenter une implémentation minimale de, par exemple :
	
	- OleDbAbstraction
	- OleDbAbstractionFactory
	
	afin de vérifier si l'on peut accéder indifféremment à Firebird
	et à une base de données parlant OLE DB (ou autre).

13. Définir ISqlBuilder

14. Implémenter FirebirdSqlBuilder, OleDbSqlBuilder minimal.


Implémentation (suite)
----------------------

Bien que cela puisse paraître redondant, j'ai défini des classes pour
la représentation des tables et des colonnes. Contrairement à DataTable,
la SqlTable n'est pas prévue pour stocker des données, mais juste pour
stocker les informations de schéma.

Les classes SqlTable et SqlColumn sont donc utilisées principalement
par ISqlBuilder, ainsi que par IDbAbstraction, pour décrire le schéma
de la base de données.


- Vérifier l'implémentation de InternalCollectionList et de ses classes
  dérivées, à savoir SqlColumnCollection, SqlFieldCollection, ...

- Ecrire les tests pour SqlTable, SqlColumn, SqlColumnCollection.

- Implémenter FirebirdAbstraction.QueryTableNames et QueryTableSchema;
  ces méthodes sont étroitement liées à une implémentation de ISqlBuilder
  et il faudra voir si la classe FirebirdAbstraction implémente elle-
  même ISqlBuilder, ou si elle délègue cette tâche à une classe annexe.

- Compléter la classe SqlField.

- Ecrire les tests pour SqlField, SqlFunction, SqlSelect, si c'est
  jugé utile. Peut-être ces classes sont-elles suffisamment simples
  pour ne pas nécessiter de tests spécifiques.


Détails au sujet de SqlSelect
-----------------------------

La commande SELECT en SQL est très riche. La classe SqlSelect tente
de représenter un sous-ensemble utile de ce que SELECT sait faire.

Un certain nombre d'informations ne sont pas stockées explicitement
par l'objet SqlSelect. En particulier :

- Lorsqu'un ou plusieurs des champs du SELECT sont de type Aggregate,
  le SELECT doit comporter une clause GROUP BY. Les champs listés par
  GROUP BY sont dérivés implicitement de la liste des champs: tous
  les champs de type non-aggrégat y figurent.

- Les informations de tri pour la clause ORDER BY sont intégrées
  directement dans les spécifications des champs, au moyen de la
  propriété SqlField.Order.

- A la place des spécifications des tables, il est bien sûr aussi
  possible de spécifier des sous-requêtes via SqlField...
  
  Note: l'alias des tables est indispensable pour spécifier les
        noms des champs du SELECT.

- On peut créer des requêtes SQL de type 'set', à savoir plusieurs
  SELECT composés au moyen de UNION, EXCEPT ou INTERSECT.
  
  Note: dans ce cas, le SqlSelectPredicate apparaît avant le deuxième
        SELECT, alors que pour le premier SELECT, il apparaît après.
        Ex.: SELECT >DISTINCT< ... UNION >DISTINCT< SELECT ...
  
  Pour créer ces requêtes, il faut utiliser SqlSelect.Add pour
  réaliser le chaînage.

- Les termes de la clause WHERE sont spécifiées en terme de SqlField,
  mais seules des fonctions ou des procédures peuvent y être utilisées
  pour l'instant.

- Les JOINs sont spécifiés indirectement au moyen des termes de la
  clause WHERE (SqlSelect.Condition), où SqlField.Type == Function
  et SqlField.AsFunction.Type == SqlFunctionType.InnerJoin. Dans un
  tel cas, les deux termes A et B de la SqlFunction doivent être
  des noms qualifiés (nom de table + nom de colonne), car ISqlBuilder
  doit être capable de retrouver le nom des tables pour construire la
  clause 'FROM Table1 JOIN Table2 ON Table1.id = Table2.id'.

- La clause GROUP BY n'est pas supportée.


Détails sur ISqlBuilder.Insert/Update/RemoveData
------------------------------------------------

L'insertion de données dans une table nécessite à la fois un nom de
table et un nom de colonne par champ à écrire. Le nom de la table est
passé explicitement à l'appel ISqlBuilder.InsertData et les noms des
champs sont extraits au moyen de SqlField.Alias.

Pour l'instant, ISqlBuilder ne supporte pas d'insertion à partir de
données provenant directement d'une requête de type SELECT. Certaines
base n'aiment pas cela, et on peut s'en passer au prix d'un "hop"
supplémentaire entre la base de données et le logiciel.

ISqlBuilder ne supporte pas non plus les mises à jour de type "UPDATE
Table SET ROW = ... WHERE ...", mais uniquement la version "UPDATE Table
SET ... WHERE ...". Les conditions de mise à jour pour la clause WHERE
sont extraites d'une SqlFieldCollection; chaque SqlField référence une
fonction de comparaison (SqlFunction.Type = Compare). Tous les termes
sont unis par des AND. Si on désire faire des OR, il faut construire
soi-même l'arbre des SqlFunction.

