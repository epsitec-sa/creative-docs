//	Copyright © 2005-2008, EPSITEC SA, 1400 Yverdon-les-Bains, Switzerland
//	Author: Pierre ARNAUD, Maintainer: Pierre ARNAUD

using Epsitec.Common.Support;
using System.Collections.Generic;

namespace Epsitec.Common.Tool.ResGenerator
{
	class Application
	{
		[System.STAThread]
		static void Main(string[] args)
		{
			string[] paths = new string[]
			{
				@"S:\Epsitec.Cresus\Common.Dialogs\Resources",
				@"S:\Epsitec.Cresus\Common.Designer\Resources",
				@"S:\Epsitec.Cresus\Common.Document\Resources",
				@"S:\Epsitec.Cresus\Common.Support\Resources",
				@"S:\Epsitec.Cresus\Common.Types\Resources",
				@"S:\Epsitec.Cresus\Common.Widgets\Resources",
				@"S:\Epsitec.Cresus\Common.DocumentEditor\Resources",
			};

			Epsitec.Common.Support.Implementation.FileProvider.DefineGlobalProbingPath (string.Join (";", paths));
			
			if (args.Length == 2)
			{
				Application.Process (args[0], args[1]);
				System.Console.Out.WriteLine ("Done.");
			}
			else if (System.IO.File.Exists ("build.ini"))
			{
				Application.ProcessBuildFile ("build.ini");

				System.Console.Out.WriteLine ("Done.");
			}
			else
			{
				System.Console.Out.WriteLine ("Invalid command line and no 'build.ini' script found.");
			}
		}

		/// <summary>
		/// Processes the build file. Skips comments and empty lines and executes
		/// individual generation directives.
		/// </summary>
		/// <param name="buildFileName">Name of the build file.</param>
		static void ProcessBuildFile(string buildFileName)
		{
			string[] args;

			using (System.IO.StreamReader reader = new System.IO.StreamReader (buildFileName, System.Text.Encoding.UTF8))
			{
				for (int count = 0; ; count++)
				{
					string line = reader.ReadLine ();

					if (line == null)
					{
						break;
					}

					line = line.Trim ();

					if ((line.Length == 0) ||
						(line.StartsWith ("#")) ||
						(line.StartsWith ("//")))
					{
						continue;
					}

					args = line.Split ('=');

					if (args.Length == 2)
					{
						Application.Process (args[0], args[1]);
					}
					else
					{
						System.Console.Error.WriteLine ("Error: {0}:{1}: syntax error.", buildFileName, count);
					}
				}
			}
		}

		/// <summary>
		/// Processes the specified command line. There are two arguments: the default
		/// namespace and the application directory.
		/// </summary>
		/// <param name="defaultNamespace">The default namespace.</param>
		/// <param name="moduleDirectory">The module directory.</param>
		static void Process(string defaultNamespace, string moduleDirectory)
		{
			string moduleName = "x";

			defaultNamespace = defaultNamespace.Trim ();
			moduleDirectory  = moduleDirectory.Trim ();

			//	The directory name may contain the short application module name;
			//	this is encoded as "directory|module".

			if (moduleDirectory.IndexOf ("|") > 0)
			{
				string[] split = moduleDirectory.Split ('|');

				moduleDirectory = split[0];
				moduleName      = split[1];
			}

			int moduleId = Application.GenerateResFile (moduleDirectory, defaultNamespace, moduleName);

			System.Console.Out.WriteLine ("Generated 'Res.cs' for {0}\n  module '{1}' with id={2}.", moduleDirectory, moduleName, moduleId);
		}

		/// <summary>
		/// Generates the <c>"Res.cs"</c> file for a given module.
		/// </summary>
		/// <param name="moduleDirectory">The module directory.</param>
		/// <param name="defaultNamespace">The default namespace.</param>
		/// <param name="moduleName">Name of the module.</param>
		static int GenerateResFile(string moduleDirectory, string defaultNamespace, string moduleName)
		{
			ResourceManager manager = new ResourceManager (moduleDirectory);

			manager.DefineDefaultModuleName (moduleName);

			System.Diagnostics.Debug.Assert (manager.DefaultModuleId >= 0);

			System.Text.StringBuilder buffer = new System.Text.StringBuilder ();

			Generator generator = new Generator (buffer);

			buffer.Append ("//\tAutomatically generated by ResGenerator, on ");
			buffer.Append (System.DateTime.Now.ToString ("d", System.Threading.Thread.CurrentThread.CurrentCulture));
			buffer.Append ("\n");
			buffer.Append ("//\tDo not edit manually.\n\n");

			generator.BeginBlock ("namespace", defaultNamespace);
			generator.BeginBlock ("public static class", "Res");

			string[] bundleIds = manager.GetBundleIds ("*", "*", ResourceLevel.Default);

			Application.commandsGenerated = false;

			bool addLine = false;

			foreach (string bundleId in bundleIds)
			{
				ResourceBundle bundle = manager.GetBundle (bundleId, ResourceLevel.Default);

				if (bundle == null)
				{
					System.Console.Error.WriteLine ("Bundle {0} could not be loaded.", bundleId);
					continue;
				}

				string bundleType = bundle.Type;

				if (addLine)
				{
					buffer.Append (generator.Tabs);
					buffer.Append ("\n");
				}

				buffer.Append (generator.Tabs);
				buffer.Append ("//\tCode mapping for '");
				buffer.Append (bundleType);
				buffer.Append ("' resources\n");
				
				switch (bundleType)
				{
					case Resources.StringTypeName:
						Application.GenerateStrings (manager, buffer, generator, defaultNamespace, bundleId, bundle);
						addLine = true;
						break;
					case Resources.CaptionTypeName:
						Application.GenerateCommandsCaptionsAndTypes (manager, buffer, generator, defaultNamespace, bundleId, bundle);
						addLine = true;
						break;
				}
			}

			buffer.Append (generator.Tabs);
			buffer.Append ("\n");

			generator.BeginBlock ("static", "Res()");
			buffer.Append (generator.Tabs);
			buffer.Append (@"Res.Initialize (typeof (Res), """);
			buffer.Append (moduleName);
			buffer.Append (@""");");
			buffer.Append ("\n");
			generator.EndBlock ();
			buffer.Append ("\n");

			generator.BeginBlock ("public static void", "Initialize()");
			generator.EndBlock ();
			buffer.Append ("\n");

			generator.BeginBlock ("private static void", "Initialize(System.Type type, string name)");
			buffer.Append (generator.Tabs);
			buffer.Append (@"Res._manager = new global::Epsitec.Common.Support.ResourceManager (type);");
			buffer.Append ("\n");
			buffer.Append (generator.Tabs);
			buffer.Append (@"Res._manager.DefineDefaultModuleName (name);");
			buffer.Append ("\n");
			if (Application.commandsGenerated)
			{
				buffer.Append (generator.Tabs);
				buffer.Append (@"Commands._Initialize ();");
				buffer.Append ("\n");
			}
			generator.EndBlock ();

			buffer.Append (generator.Tabs);
			buffer.Append ("\n");

			generator.BeginBlock ("public static global::Epsitec.Common.Support.ResourceManager", "Manager");
			buffer.Append (generator.Tabs);
			buffer.Append (@"get { return Res._manager; }");
			buffer.Append ("\n");
			generator.EndBlock ();

			buffer.Append (generator.Tabs);
			buffer.Append ("\n");

			generator.BeginBlock ("public static int", "ModuleId");
			buffer.Append (generator.Tabs);
			buffer.Append (@"get { return _moduleId; }");
			buffer.Append ("\n");
			generator.EndBlock ();

			buffer.Append (generator.Tabs);
			buffer.Append ("\n");

			buffer.Append (generator.Tabs);
			buffer.Append ("private static global::Epsitec.Common.Support.ResourceManager _manager = global::Epsitec.Common.Support.Resources.DefaultManager;");
			buffer.Append ("\n");
			buffer.Append (generator.Tabs);
			buffer.Append ("private const int _moduleId = ");
			buffer.AppendFormat (System.Globalization.CultureInfo.InvariantCulture, "{0};", manager.DefaultModuleId);
			buffer.Append ("\n");

			generator.EndBlock ();
			generator.EndBlock ();

			using (System.IO.StreamWriter file = new System.IO.StreamWriter (System.IO.Path.Combine (moduleDirectory, "Res.cs"), false, System.Text.Encoding.UTF8))
			{
				file.Write (buffer.ToString ());
			}

			return manager.DefaultModuleId;
		}

		static void GenerateCommandsCaptionsAndTypes(ResourceManager manager, System.Text.StringBuilder buffer, Generator generator, string defaultNamespace, string bundleId, ResourceBundle bundle)
		{
			List<string> cmdFields = new List<string> ();
			List<string> capFields = new List<string> ();
			List<string> typFields = new List<string> ();
			List<string> valFields = new List<string> ();
			List<string> fldFields = new List<string> ();

			foreach (string field in bundle.FieldNames)
			{
				if (field.StartsWith ("Cmd."))
				{
					cmdFields.Add (field);
				}
				else if (field.StartsWith ("Cap."))
				{
					capFields.Add (field);
				}
				else if (field.StartsWith ("Typ."))
				{
					typFields.Add (field);
				}
				else if (field.StartsWith ("Val."))
				{
					valFields.Add (field);
				}
				else if (field.StartsWith ("Fld."))
				{
					fldFields.Add (field);
				}
				else
				{
					System.Console.Error.WriteLine ("Field {0} not supported in {1}.", field, bundleId);
				}
			}

			if (cmdFields.Count > 1)
			{
				buffer.Append (generator.Tabs);
				buffer.Append ("\n");
				Application.GenerateCommands (manager, buffer, generator, defaultNamespace, bundleId, bundle, cmdFields);

				buffer.Append (generator.Tabs);
				buffer.Append ("\n");
				Application.GenerateCommandIds (manager, buffer, generator, defaultNamespace, bundleId, bundle, cmdFields);
			}

			if (capFields.Count > 1)
			{
				buffer.Append (generator.Tabs);
				buffer.Append ("\n");
				Application.GenerateCaptions (manager, buffer, generator, defaultNamespace, bundleId, bundle, capFields);
			}

			if (typFields.Count > 1)
			{
				buffer.Append (generator.Tabs);
				buffer.Append ("\n");
				Application.GenerateTypes (manager, buffer, generator, defaultNamespace, bundleId, bundle, typFields);
			}

			if (valFields.Count > 1)
			{
				buffer.Append (generator.Tabs);
				buffer.Append ("\n");
				Application.GenerateValues (manager, buffer, generator, defaultNamespace, bundleId, bundle, valFields);
			}

			if (fldFields.Count > 1)
			{
				buffer.Append (generator.Tabs);
				buffer.Append ("\n");
				Application.GenerateFields (manager, buffer, generator, defaultNamespace, bundleId, bundle, fldFields);
			}
		}

		static void GenerateCommands(ResourceManager manager, System.Text.StringBuilder buffer, Generator generator, string defaultNamespace, string bundleId, ResourceBundle bundle, List<string> cmdFields)
		{
			Application.commandsGenerated = true;
			string prefix   = "";
			bool addNewline = false;

			generator.BeginBlock ("public static class", "Commands");

			string[] fields   = new string[cmdFields.Count];
			string[] sortKeys = new string[cmdFields.Count];

			for (int i = 0; i < fields.Length; i++)
			{
				fields[i] = cmdFields[i];

				int pos = fields[i].LastIndexOf ('.');
				if (pos < 0)
				{
					sortKeys[i] = fields[i];
				}
				else
				{
					sortKeys[i] = string.Concat (fields[i].Substring (0, pos), "!", fields[i].Substring (pos+1));
				}
			}

			System.Array.Sort (sortKeys, fields);

			List<string> classes = new List<string> ();

			for (int i = 0; i < fields.Length; i++)
			{
				string field = fields[i].Substring (4);

				while (prefix != "" && !field.StartsWith (prefix + "."))
				{
					//	Remonte d'un niveau dans la hiérarchie des classes.
					string[] args = prefix.Split ('.');
					string last = args[args.Length-1];

					generator.EndBlock ();

					prefix = prefix.Substring (0, System.Math.Max (0, prefix.Length-last.Length-1));
					addNewline = true;
				}

				string delta = prefix.Length == 0 ? field : field.Substring (prefix.Length+1);

				if (addNewline)
				{
					buffer.Append (generator.Tabs);
					buffer.Append ("\n");
					addNewline = false;
				}

				//	Crée les classes manquantes, si besoin :
				while (delta.IndexOf ('.') > -1)
				{
					string[] args = delta.Split ('.');
					string elem = args[0];

					generator.BeginBlock ("public static class", elem);

					System.Text.StringBuilder fullClass = new System.Text.StringBuilder ();
					args = field.Split ('.');

					for (int j = 0; j < args.Length-1; j++)
					{
						if (j > 0)
						{
							fullClass.Append (".");
						}
						
						fullClass.Append (args[j]);
					}

					if (!classes.Contains (fullClass.ToString ()))
					{
						classes.Add (fullClass.ToString ());
						System.Diagnostics.Debug.WriteLine (fullClass.ToString ());
					}

					buffer.Append (generator.Tabs);
					buffer.Append ("internal static void _Initialize() { }\n");
					buffer.Append (generator.Tabs);
					buffer.Append ("\n");

					if (prefix.Length == 0)
					{
						prefix = elem;
					}
					else
					{
						prefix = string.Concat (prefix, ".", elem);
					}

					delta = field.Substring (prefix.Length + 1);
				}

				//	Crée l'accesseur pour le champ actuel :

				Support.Druid localDruid = bundle[fields[i]].Id;
				Druid moduleDruid = new Druid (localDruid, bundle.Module.Id);

				buffer.Append (string.Concat (generator.Tabs, "//\tdesigner:cap/", moduleDruid.ToString ().Trim ('[', ']'), "\n"));
				buffer.Append (generator.Tabs);
				
				buffer.Append ("public static readonly global::Epsitec.Common.Widgets.Command ");
				buffer.Append (delta);
				buffer.Append (@" = global::Epsitec.Common.Widgets.Command.Get (new global::Epsitec.Common.Support.Druid (_moduleId, ");
				buffer.Append (localDruid.DeveloperAndPatchLevel.ToString (System.Globalization.CultureInfo.InvariantCulture));
				buffer.Append (", ");
				buffer.Append (localDruid.Local.ToString (System.Globalization.CultureInfo.InvariantCulture));
				buffer.Append ("));\n");
			}

			//	Referme les classes ouvertes :
			if (prefix.Length > 0)
			{
				string[] args = prefix.Split ('.');

				for (int j=0; j<args.Length; j++)
				{
					generator.EndBlock ();
				}
			}
			buffer.Append (generator.Tabs);
			buffer.Append ("\n");

			generator.BeginBlock ("internal static void", "_Initialize()");
			for (int i = 0; i < classes.Count; i++)
			{
				buffer.Append (generator.Tabs);
				buffer.Append (classes[i]);
				buffer.Append (".");
				buffer.Append ("_Initialize ();\n");
			}
			generator.EndBlock ();

			generator.EndBlock ();
		}

		static void GenerateCommandIds(ResourceManager manager, System.Text.StringBuilder buffer, Generator generator, string defaultNamespace, string bundleId, ResourceBundle bundle, List<string> cmdFields)
		{
			string prefix   = "";
			bool addNewline = false;

			generator.BeginBlock ("public static class", "CommandIds");

			string[] fields   = new string[cmdFields.Count];
			string[] sortKeys = new string[cmdFields.Count];

			for (int i = 0; i < fields.Length; i++)
			{
				fields[i] = cmdFields[i];

				int pos = fields[i].LastIndexOf ('.');
				if (pos < 0)
				{
					sortKeys[i] = fields[i];
				}
				else
				{
					sortKeys[i] = string.Concat (fields[i].Substring (0, pos), "!", fields[i].Substring (pos+1));
				}
			}

			System.Array.Sort (sortKeys, fields);

			List<string> classes = new List<string> ();

			for (int i = 0; i < fields.Length; i++)
			{
				string field = fields[i].Substring (4);

				while (prefix != "" && !field.StartsWith (prefix + "."))
				{
					//	Remonte d'un niveau dans la hiérarchie des classes.
					string[] args = prefix.Split ('.');
					string last = args[args.Length-1];

					generator.EndBlock ();

					prefix = prefix.Substring (0, System.Math.Max (0, prefix.Length-last.Length-1));
					addNewline = true;
				}

				string delta = prefix.Length == 0 ? field : field.Substring (prefix.Length+1);

				if (addNewline)
				{
					buffer.Append (generator.Tabs);
					buffer.Append ("\n");
					addNewline = false;
				}

				//	Crée les classes manquantes, si besoin :
				while (delta.IndexOf ('.') > -1)
				{
					string[] args = delta.Split ('.');
					string elem = args[0];

					generator.BeginBlock ("public static class", elem);
					classes.Add (elem);

					buffer.Append (generator.Tabs);
					buffer.Append ("\n");

					if (prefix.Length == 0)
					{
						prefix = elem;
					}
					else
					{
						prefix = string.Concat (prefix, ".", elem);
					}

					delta = field.Substring (prefix.Length + 1);
				}

				//	Crée l'accesseur pour le champ actuel :

				Support.Druid druid = bundle[fields[i]].Id;

				druid = new Support.Druid (druid, manager.DefaultModuleId);

				buffer.Append (string.Concat (generator.Tabs, "//\tdesigner:cap/", druid.ToString ().Trim ('[', ']'), "\n"));
				buffer.Append (generator.Tabs);

				buffer.Append ("public const long ");
				buffer.Append (delta);
				buffer.Append (@" = 0x");
				buffer.Append (druid.ToLong ().ToString ("X"));
				buffer.Append ("L;\n");
			}

			//	Referme les classes ouvertes :
			if (prefix.Length > 0)
			{
				string[] args = prefix.Split ('.');

				for (int j=0; j<args.Length; j++)
				{
					generator.EndBlock ();
				}
			}

			generator.EndBlock ();
		}

		static void GenerateCaptions(ResourceManager manager, System.Text.StringBuilder buffer, Generator generator, string defaultNamespace, string bundleId, ResourceBundle bundle, List<string> capFields)
		{
			string prefix   = "";
			bool addNewline = false;

			generator.BeginBlock ("public static class", "Captions");

			string[] fields   = new string[capFields.Count];
			string[] sortKeys = new string[capFields.Count];

			for (int i = 0; i < fields.Length; i++)
			{
				fields[i] = capFields[i];

				int pos = fields[i].LastIndexOf ('.');
				if (pos < 0)
				{
					sortKeys[i] = fields[i];
				}
				else
				{
					sortKeys[i] = string.Concat (fields[i].Substring (0, pos), "!", fields[i].Substring (pos+1));
				}
			}

			System.Array.Sort (sortKeys, fields);

			for (int i = 0; i < fields.Length; i++)
			{
				string field = fields[i].Substring (4);

				while (prefix != "" && !field.StartsWith (prefix + "."))
				{
					//	Remonte d'un niveau dans la hiérarchie des classes.
					string[] args = prefix.Split ('.');
					string last = args[args.Length-1];

					generator.EndBlock ();

					prefix = prefix.Substring (0, System.Math.Max (0, prefix.Length-last.Length-1));
					addNewline = true;
				}

				string delta = prefix.Length == 0 ? field : field.Substring (prefix.Length+1);

				if (addNewline)
				{
					buffer.Append (generator.Tabs);
					buffer.Append ("\n");
					addNewline = false;
				}

				//	Crée les classes manquantes, si besoin :
				while (delta.IndexOf ('.') > -1)
				{
					string[] args = delta.Split ('.');
					string elem = args[0];

					generator.BeginBlock ("public static class", elem);

					if (prefix.Length == 0)
					{
						prefix = elem;
					}
					else
					{
						prefix = string.Concat (prefix, ".", elem);
					}

					delta = field.Substring (prefix.Length + 1);
				}

				//	Crée l'accesseur pour le champ actuel :

				Support.Druid localDruid = bundle[fields[i]].Id;
				Druid moduleDruid = new Druid (localDruid, bundle.Module.Id);

				buffer.Append (string.Concat (generator.Tabs, "//\tdesigner:cap/", moduleDruid.ToString ().Trim ('[', ']'), "\n"));
				buffer.Append (generator.Tabs);

				buffer.Append ("public static global::Epsitec.Common.Types.Caption ");
				buffer.Append (delta);
				buffer.Append (@" { get { return Res._manager.GetCaption (new global::Epsitec.Common.Support.Druid (_moduleId, ");
				buffer.Append (localDruid.DeveloperAndPatchLevel.ToString (System.Globalization.CultureInfo.InvariantCulture));
				buffer.Append (", ");
				buffer.Append (localDruid.Local.ToString (System.Globalization.CultureInfo.InvariantCulture));
				buffer.Append (")); } }\n");
			}

			//	Referme les classes ouvertes :
			if (prefix.Length > 0)
			{
				string[] args = prefix.Split ('.');

				for (int j=0; j<args.Length; j++)
				{
					generator.EndBlock ();
				}
			}
			buffer.Append (generator.Tabs);
			buffer.Append ("\n");

			generator.EndBlock ();
		}

		static void GenerateValues(ResourceManager manager, System.Text.StringBuilder buffer, Generator generator, string defaultNamespace, string bundleId, ResourceBundle bundle, List<string> valFields)
		{
			string prefix   = "";
			bool addNewline = false;

			generator.BeginBlock ("public static class", "Values");

			string[] fields   = new string[valFields.Count];
			string[] sortKeys = new string[valFields.Count];

			for (int i = 0; i < fields.Length; i++)
			{
				fields[i] = valFields[i];

				int pos = fields[i].LastIndexOf ('.');
				if (pos < 0)
				{
					sortKeys[i] = fields[i];
				}
				else
				{
					sortKeys[i] = string.Concat (fields[i].Substring (0, pos), "!", fields[i].Substring (pos+1));
				}
			}

			System.Array.Sort (sortKeys, fields);

			for (int i = 0; i < fields.Length; i++)
			{
				string field = fields[i].Substring (4);

				while (prefix != "" && !field.StartsWith (prefix + "."))
				{
					//	Remonte d'un niveau dans la hiérarchie des classes.
					string[] args = prefix.Split ('.');
					string last = args[args.Length-1];

					generator.EndBlock ();

					prefix = prefix.Substring (0, System.Math.Max (0, prefix.Length-last.Length-1));
					addNewline = true;
				}

				string delta = prefix.Length == 0 ? field : field.Substring (prefix.Length+1);

				if (addNewline)
				{
					buffer.Append (generator.Tabs);
					buffer.Append ("\n");
					addNewline = false;
				}

				//	Crée les classes manquantes, si besoin :
				while (delta.IndexOf ('.') > -1)
				{
					string[] args = delta.Split ('.');
					string elem = args[0];

					generator.BeginBlock ("public static class", elem);

					if (prefix.Length == 0)
					{
						prefix = elem;
					}
					else
					{
						prefix = string.Concat (prefix, ".", elem);
					}

					delta = field.Substring (prefix.Length + 1);
				}

				//	Crée l'accesseur pour le champ actuel :
				
				Support.Druid localDruid = bundle[fields[i]].Id;
				Druid moduleDruid = new Druid (localDruid, bundle.Module.Id);

				buffer.Append (string.Concat (generator.Tabs, "//\tdesigner:cap/", moduleDruid.ToString ().Trim ('[', ']'), "\n"));
				buffer.Append (generator.Tabs);

				buffer.Append ("public static global::Epsitec.Common.Types.Caption ");
				buffer.Append (delta);
				buffer.Append (@" { get { return Res._manager.GetCaption (new global::Epsitec.Common.Support.Druid (_moduleId, ");
				buffer.Append (localDruid.DeveloperAndPatchLevel.ToString (System.Globalization.CultureInfo.InvariantCulture));
				buffer.Append (", ");
				buffer.Append (localDruid.Local.ToString (System.Globalization.CultureInfo.InvariantCulture));
				buffer.Append (")); } }\n");
			}

			//	Referme les classes ouvertes :
			if (prefix.Length > 0)
			{
				string[] args = prefix.Split ('.');

				for (int j = 0; j < args.Length; j++)
				{
					generator.EndBlock ();
				}
			}

			generator.EndBlock ();
		}

		static void GenerateFields(ResourceManager manager, System.Text.StringBuilder buffer, Generator generator, string defaultNamespace, string bundleId, ResourceBundle bundle, List<string> fldFields)
		{
			string prefix   = "";
			bool addNewline = false;

			generator.BeginBlock ("public static class", "Fields");

			string[] fields   = new string[fldFields.Count];
			string[] sortKeys = new string[fldFields.Count];

			for (int i = 0; i < fields.Length; i++)
			{
				fields[i] = fldFields[i];

				int pos = fields[i].LastIndexOf ('.');
				if (pos < 0)
				{
					sortKeys[i] = fields[i];
				}
				else
				{
					sortKeys[i] = string.Concat (fields[i].Substring (0, pos), "!", fields[i].Substring (pos+1));
				}
			}

			System.Array.Sort (sortKeys, fields);

			for (int i = 0; i < fields.Length; i++)
			{
				string field = fields[i].Substring (4);

				while (prefix != "" && !field.StartsWith (prefix + "."))
				{
					//	Remonte d'un niveau dans la hiérarchie des classes.
					string[] args = prefix.Split ('.');
					string last = args[args.Length-1];

					generator.EndBlock ();

					prefix = prefix.Substring (0, System.Math.Max (0, prefix.Length-last.Length-1));
					addNewline = true;
				}

				string delta = prefix.Length == 0 ? field : field.Substring (prefix.Length+1);

				if (addNewline)
				{
					buffer.Append (generator.Tabs);
					buffer.Append ("\n");
					addNewline = false;
				}

				//	Crée les classes manquantes, si besoin :
				while (delta.IndexOf ('.') > -1)
				{
					string[] args = delta.Split ('.');
					string elem = args[0];

					generator.BeginBlock ("public static class", elem);

					if (prefix.Length == 0)
					{
						prefix = elem;
					}
					else
					{
						prefix = string.Concat (prefix, ".", elem);
					}

					delta = field.Substring (prefix.Length + 1);
				}

				//	Crée l'accesseur pour le champ actuel :
				
				Support.Druid localDruid = bundle[fields[i]].Id;
				Druid moduleDruid = new Druid (localDruid, bundle.Module.Id);

				buffer.Append (string.Concat (generator.Tabs, "//\tdesigner:cap/", moduleDruid.ToString ().Trim ('[', ']'), "\n"));
				buffer.Append (generator.Tabs);

				buffer.Append ("public static readonly global::Epsitec.Common.Support.Druid ");
				buffer.Append (delta);
				buffer.Append (@" = new global::Epsitec.Common.Support.Druid (_moduleId, ");
				buffer.Append (localDruid.DeveloperAndPatchLevel.ToString (System.Globalization.CultureInfo.InvariantCulture));
				buffer.Append (", ");
				buffer.Append (localDruid.Local.ToString (System.Globalization.CultureInfo.InvariantCulture));
				buffer.Append (");\n");
			}

			//	Referme les classes ouvertes :
			if (prefix.Length > 0)
			{
				string[] args = prefix.Split ('.');

				for (int j = 0; j < args.Length; j++)
				{
					generator.EndBlock ();
				}
			}

			generator.EndBlock ();
		}

		static void GenerateTypes(ResourceManager manager, System.Text.StringBuilder buffer, Generator generator, string defaultNamespace, string bundleId, ResourceBundle bundle, List<string> typFields)
		{
			string prefix   = "";
			bool addNewline = false;

			generator.BeginBlock ("public static class", "Types");

			string[] fields   = new string[typFields.Count];
			string[] sortKeys = new string[typFields.Count];

			for (int i = 0; i < fields.Length; i++)
			{
				fields[i] = typFields[i];

				int pos = fields[i].LastIndexOf ('.');
				if (pos < 0)
				{
					sortKeys[i] = fields[i];
				}
				else
				{
					sortKeys[i] = string.Concat (fields[i].Substring (0, pos), "!", fields[i].Substring (pos+1));
				}
			}

			System.Array.Sort (sortKeys, fields);

			string[] wellKnownPrefixes = new string[] { "CollectionType.", "StructuredType." };

			for (int i = 0; i < fields.Length; i++)
			{
				string field = fields[i].Substring (4);

				foreach (string wellKnownPrefix in wellKnownPrefixes)
				{
					if (field.StartsWith (wellKnownPrefix))
					{
						field = field.Substring (wellKnownPrefix.Length);
						break;
					}
				}

				while (prefix != "" && !field.StartsWith (prefix + "."))
				{
					//	Remonte d'un niveau dans la hiérarchie des classes.
					string[] args = prefix.Split ('.');
					string last = args[args.Length-1];

					generator.EndBlock ();

					prefix = prefix.Substring (0, System.Math.Max (0, prefix.Length-last.Length-1));
					addNewline = true;
				}

				string delta = prefix.Length == 0 ? field : field.Substring (prefix.Length+1);

				if (addNewline)
				{
					buffer.Append (generator.Tabs);
					buffer.Append ("\n");
					addNewline = false;
				}

				//	Crée les classes manquantes, si besoin :
				while (delta.IndexOf ('.') > -1)
				{
					string[] args = delta.Split ('.');
					string elem = args[0];

					generator.BeginBlock ("public static class", elem);

					if (prefix.Length == 0)
					{
						prefix = elem;
					}
					else
					{
						prefix = string.Concat (prefix, ".", elem);
					}

					delta = field.Substring (prefix.Length + 1);
				}

				//	Crée l'accesseur pour le champ actuel :
				Support.ResourceBundle.Field f = bundle[fields[i]];
				Support.Druid localDruid = f.Id;

				string s = f.AsString;

				if (string.IsNullOrEmpty (s))
				{
					continue;
				}

				Types.Caption caption = new Types.Caption ();
				caption.DeserializeFromString (s, manager);

				Types.AbstractType type = Types.TypeRosetta.CreateTypeObject (caption);

				if (type == null)
				{
					continue;
				}

				//	Cherche le nom du type complet, par exemple "Epsitec.Common.Types.StringType"
				string typeName = type.ToString ();

				Druid moduleDruid = new Druid (localDruid, bundle.Module.Id);
				
				buffer.Append (string.Concat (generator.Tabs, "//\tdesigner:cap/", moduleDruid.ToString ().Trim ('[', ']'), "\n"));
				buffer.Append (generator.Tabs);
				
				buffer.Append ("public static readonly global::");
				buffer.Append (typeName);
				buffer.Append (" ");
				buffer.Append (delta);
				buffer.Append (" = (global::");
				buffer.Append (typeName);
				buffer.Append (") global::Epsitec.Common.Types.TypeRosetta.CreateTypeObject (");
				buffer.Append ("new global::Epsitec.Common.Support.Druid (_moduleId, ");
				buffer.Append (localDruid.DeveloperAndPatchLevel.ToString (System.Globalization.CultureInfo.InvariantCulture));
				buffer.Append (", ");
				buffer.Append (localDruid.Local.ToString (System.Globalization.CultureInfo.InvariantCulture));
				buffer.Append ("));\n");
			}

			//	Referme les classes ouvertes :
			if (prefix.Length > 0)
			{
				string[] args = prefix.Split ('.');

				for (int j = 0; j < args.Length; j++)
				{
					generator.EndBlock ();
				}
			}

			generator.EndBlock ();
		}

		static void GenerateStrings(ResourceManager manager, System.Text.StringBuilder buffer, Generator generator, string defaultNamespace, string bundleId, ResourceBundle bundle)
		{
			buffer.Append (generator.Tabs);
			buffer.Append ("\n");
			
			string prefix   = "";
			bool addNewline = false;

			generator.BeginBlock ("public static class", bundleId);

			string[] fields   = bundle.FieldNames;
			string[] sortKeys = new string[fields.Length];

			for (int i = 0; i < fields.Length; i++)
			{
				int pos = fields[i].LastIndexOf ('.');

				if (pos < 0)
				{
					sortKeys[i] = fields[i];
				}
				else
				{
					sortKeys[i] = string.Concat (fields[i].Substring (0, pos), "!", fields[i].Substring (pos+1));
				}
			}

			System.Array.Sort (sortKeys, fields);

			for (int i = 0; i < fields.Length; i++)
			{
				string field = fields[i];

				while ((prefix != "") && (field.StartsWith (prefix + ".") == false))
				{
					//	Remonte d'un niveau dans la hiérarchie des classes.

					string[] args = prefix.Split ('.');
					string last = args[args.Length-1];

					generator.EndBlock ();

					prefix = prefix.Substring (0, System.Math.Max (0, prefix.Length - last.Length - 1));
					addNewline = true;
				}

				string delta = prefix.Length == 0 ? field : field.Substring (prefix.Length + 1);

				if (addNewline)
				{
					buffer.Append (generator.Tabs);
					buffer.Append ("\n");
					addNewline = false;
				}

				//	Crée les classes manquantes, si besoin :

				while (delta.IndexOf ('.') > -1)
				{
					string[] args = delta.Split ('.');
					string elem = args[0];

					generator.BeginBlock ("public static class", elem);

					if (prefix.Length == 0)
					{
						prefix = elem;
					}
					else
					{
						prefix = string.Concat (prefix, ".", elem);
					}

					delta = field.Substring (prefix.Length + 1);
				}

				//	Crée l'accesseur pour le champ actuel :

				Druid localDruid = bundle[field].Id;
				Druid moduleDruid = new Druid (localDruid, bundle.Module.Id);

				buffer.Append (string.Concat (generator.Tabs, "//\tdesigner:str/", moduleDruid.ToString ().Trim ('[', ']'), "\n"));
				buffer.Append (generator.Tabs);

				buffer.Append ("public static string ");
				buffer.Append (delta);
				buffer.Append (@" { get { return global::");
				buffer.Append (defaultNamespace);
				buffer.Append (@".Res.");
				buffer.Append (bundleId);
				buffer.Append (@".GetText (");

				if (localDruid.Type == Support.DruidType.ModuleRelative)
				{
					buffer.Append (@"global::Epsitec.Common.Support.Druid.FromFieldId (");
					buffer.Append (localDruid.ToFieldId ());
					buffer.Append (@")");
				}
				else
				{
					buffer.Append (@"""");
					buffer.Append (bundleId);
					buffer.Append (@"""");

					string[] elems = field.Split ('.');

					for (int k = 0; k < elems.Length; k++)
					{
						buffer.Append (@", """);
						buffer.Append (elems[k]);
						buffer.Append (@"""");
					}
				}

				buffer.Append ("); } }\n");
			}

			//	Referme les classes ouvertes :

			if (prefix.Length > 0)
			{
				string[] args = prefix.Split ('.');

				for (int j = 0; j < args.Length; j++)
				{
					generator.EndBlock ();
				}
			}
			buffer.Append (generator.Tabs);
			buffer.Append ("\n");

			generator.BeginBlock ("public static string", "GetString(params string[] path)");

			buffer.Append (generator.Tabs);
			buffer.Append (@"string field = string.Join (""."", path);");
			buffer.Append ("\n");
			buffer.Append (generator.Tabs);
			buffer.Append (@"return _stringsBundle[field].AsString;");
			buffer.Append ("\n");

			generator.EndBlock ();

			buffer.Append (generator.Tabs);
			buffer.Append ("\n");

			buffer.Append (generator.Tabs);
			buffer.Append ("#region Internal Support Code\n");

			generator.BeginBlock ("private static string", "GetText(string bundle, params string[] path)");

			buffer.Append (generator.Tabs);
			buffer.Append (@"string field = string.Join (""."", path);");
			buffer.Append ("\n");
			buffer.Append (generator.Tabs);
			buffer.Append (@"return _stringsBundle[field].AsString;");
			buffer.Append ("\n");

			generator.EndBlock ();

			generator.BeginBlock ("private static string", "GetText(global::Epsitec.Common.Support.Druid druid)");

			buffer.Append (generator.Tabs);
			buffer.Append (@"return _stringsBundle[druid].AsString;");
			buffer.Append ("\n");

			generator.EndBlock ();

			buffer.Append (generator.Tabs);
			buffer.Append (@"private static global::Epsitec.Common.Support.ResourceBundle _stringsBundle = Res._manager.GetBundle (""");
			buffer.Append (bundleId);
			buffer.Append (@""");");
			buffer.Append ("\n");

			buffer.Append (generator.Tabs);
			buffer.Append ("#endregion\n");

			generator.EndBlock ();
		}

		static bool commandsGenerated;
	}
}
