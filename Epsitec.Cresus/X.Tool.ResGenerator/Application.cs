//	Copyright © 2005-2006, EPSITEC SA, CH-1092 BELMONT, Switzerland
//	Responsable: Pierre ARNAUD

using Epsitec.Common.Support;
using System.Collections.Generic;

namespace Epsitec.Common.Tool.ResGenerator
{
	class Application
	{
		[System.STAThread]
		static void Main(string[] args)
		{
			if (args.Length == 2)
			{
				Application.Process (args[0], args[1]);
				System.Console.Out.WriteLine ("Done.");
			}
			else if (System.IO.File.Exists ("build.ini"))
			{
				Application.ProcessBuildFile ("build.ini");
				
				System.Console.Out.WriteLine ("Done.");
			}
			else
			{
				System.Console.Out.WriteLine ("Invalid command line and no 'build.ini' script found.");
			}
		}

		/// <summary>
		/// Processes the build file. Skips comments and empty lines and executes
		/// individual generation directives.
		/// </summary>
		/// <param name="buildFileName">Name of the build file.</param>
		static void ProcessBuildFile(string buildFileName)
		{
			string[] args;
			
			using (System.IO.StreamReader reader = new System.IO.StreamReader (buildFileName, System.Text.Encoding.UTF8))
			{
				for (int count = 0; ; count++)
				{
					string line = reader.ReadLine ();

					if (line == null)
					{
						break;
					}

					line = line.Trim ();

					if ((line.Length == 0) ||
						(line.StartsWith ("#")) ||
						(line.StartsWith ("//")))
					{
						continue;
					}

					args = line.Split ('=');

					if (args.Length == 2)
					{
						Application.Process (args[0], args[1]);
					}
					else
					{
						System.Console.Error.WriteLine ("Error: {0}:{1}: syntax error.", buildFileName, count);
					}
				}
			}
		}

		/// <summary>
		/// Processes the specified command line. There are two arguments: the default
		/// namespace and the application directory.
		/// </summary>
		/// <param name="defaultNamespace">The default namespace.</param>
		/// <param name="moduleDirectory">The module directory.</param>
		static void Process(string defaultNamespace, string moduleDirectory)
		{
			string moduleName = "x";

			defaultNamespace = defaultNamespace.Trim ();
			moduleDirectory  = moduleDirectory.Trim ();
			
			//	The directory name may contain the short application module name;
			//	this is encoded as "directory|module".
			
			if (moduleDirectory.IndexOf ("|") > 0)
			{
				string[] split = moduleDirectory.Split ('|');
				
				moduleDirectory = split[0];
				moduleName      = split[1];
			}
			
			Application.GenerateResFile (moduleDirectory, defaultNamespace, moduleName);
			
			System.Console.Out.WriteLine ("Generated 'Res.cs' for {0}, application '{1}'", moduleDirectory, moduleName);
		}

		/// <summary>
		/// Generates the <c>"Res.cs"</c> file for a given module.
		/// </summary>
		/// <param name="moduleDirectory">The module directory.</param>
		/// <param name="defaultNamespace">The default namespace.</param>
		/// <param name="moduleName">Name of the module.</param>
		static void GenerateResFile(string moduleDirectory, string defaultNamespace, string moduleName)
		{
			ResourceManager manager = new ResourceManager (moduleDirectory);
			
			manager.DefineDefaultModuleName (moduleName);

			System.Diagnostics.Debug.Assert (manager.DefaultModuleId >= 0);
			
			System.Text.StringBuilder buffer = new System.Text.StringBuilder ();
			
			Generator generator = new Generator (buffer);
			
			buffer.Append ("//\tAutomatically generated by ResGenerator, on ");
			buffer.Append (System.DateTime.Now.ToString ("G", System.Threading.Thread.CurrentThread.CurrentCulture));
			buffer.Append ("\n");
			buffer.Append ("//\tDo not edit manually.\n\n");
			
			generator.BeginBlock ("namespace", defaultNamespace);
			generator.BeginBlock ("public static class", "Res");

			string[] bundleIds = manager.GetBundleIds ("*", "*", ResourceLevel.Default);

			Application.comandsGenerated = false;

			foreach (string bundleId in bundleIds)
			{
				ResourceBundle bundle = manager.GetBundle (bundleId, ResourceLevel.Default);

				if (bundle == null)
				{
					System.Console.Error.WriteLine ("Bundle {0} could not be loaded.", bundleId);
					continue;
				}

				string bundleType = bundle.Type;

				switch (bundleType)
				{
					case "String":
						Application.GenerateStrings (manager, buffer, generator, defaultNamespace, bundleId, bundle);
						break;
					case "Caption":
						Application.GenerateCommandsCaptionsAndTypes (manager, buffer, generator, defaultNamespace, bundleId, bundle);
						break;
				}
			}
			
			buffer.Append (generator.Tabs);
			buffer.Append ("\n");

			generator.BeginBlock ("public static void", "Initialize(System.Type type, string name)");
			buffer.Append (generator.Tabs);
			buffer.Append (@"_manager = new Epsitec.Common.Support.ResourceManager (type);");
			buffer.Append ("\n");
			buffer.Append (generator.Tabs);
			buffer.Append (@"_manager.DefineDefaultModuleName (name);");
			buffer.Append ("\n");
			if (Application.comandsGenerated)
			{
				buffer.Append(generator.Tabs);
				buffer.Append(@"Commands._Initialize();");
				buffer.Append("\n");
			}
			generator.EndBlock ();
			
			buffer.Append (generator.Tabs);
			buffer.Append ("\n");
			
			generator.BeginBlock ("public static Epsitec.Common.Support.ResourceManager", "Manager");
			buffer.Append (generator.Tabs);
			buffer.Append (@"get { return _manager; }");
			buffer.Append ("\n");
			generator.EndBlock ();
			
			buffer.Append (generator.Tabs);
			buffer.Append ("\n");
			
			generator.BeginBlock ("public static int", "ModuleId");
			buffer.Append (generator.Tabs);
			buffer.Append (@"get { return _moduleId; }");
			buffer.Append ("\n");
			generator.EndBlock ();
			
			buffer.Append (generator.Tabs);
			buffer.Append ("\n");
			
			buffer.Append (generator.Tabs);
			buffer.Append ("private static Epsitec.Common.Support.ResourceManager _manager = Epsitec.Common.Support.Resources.DefaultManager;");
			buffer.Append ("\n");
			buffer.Append (generator.Tabs);
			buffer.Append ("private static int _moduleId = ");
			buffer.AppendFormat (System.Globalization.CultureInfo.InvariantCulture, "{0};", manager.DefaultModuleId);
			buffer.Append ("\n");
			
			generator.EndBlock ();
			generator.EndBlock ();
			
			using (System.IO.StreamWriter file = new System.IO.StreamWriter (System.IO.Path.Combine (moduleDirectory, "Res.cs"), false, System.Text.Encoding.UTF8))
			{
				file.Write (buffer.ToString ());
			}
		}

		static void GenerateCommandsCaptionsAndTypes(ResourceManager manager, System.Text.StringBuilder buffer, Generator generator, string defaultNamespace, string bundleId, ResourceBundle bundle)
		{
			List<string> cmdFields = new List<string> ();
			List<string> capFields = new List<string> ();
			List<string> typFields = new List<string> ();

			foreach (string field in bundle.FieldNames)
			{
				if (field.StartsWith ("Cmd."))
				{
					cmdFields.Add (field);
				}
				else if (field.StartsWith ("Cap."))
				{
					capFields.Add (field);
				}
				else if (field.StartsWith ("Typ."))
				{
					typFields.Add (field);
				}
				else
				{
					System.Console.Error.WriteLine ("Field {0} not supported in {1}.", field, bundleId); 
				}
			}

			Application.GenerateCommands (manager, buffer, generator, defaultNamespace, bundleId, bundle, cmdFields);
			Application.GenerateCaptions (manager, buffer, generator, defaultNamespace, bundleId, bundle, capFields);
			Application.GenerateTypes (manager, buffer, generator, defaultNamespace, bundleId, bundle, typFields);
		}

		static void GenerateCommands(ResourceManager manager, System.Text.StringBuilder buffer, Generator generator, string defaultNamespace, string bundleId, ResourceBundle bundle, List<string> cmdFields)
		{
			Application.comandsGenerated = true;
			string prefix   = "";
			bool addNewline = false;

			generator.BeginBlock("public static class", "Commands");

			string[] fields   = new string[cmdFields.Count];
			string[] sortKeys = new string[cmdFields.Count];

			for (int i=0; i<fields.Length; i++)
			{
				fields[i] = cmdFields[i];

				int pos = fields[i].LastIndexOf('.');
				if (pos < 0)
				{
					sortKeys[i] = fields[i];
				}
				else
				{
					sortKeys[i] = string.Concat(fields[i].Substring(0, pos), "!", fields[i].Substring(pos+1));
				}
			}

			System.Array.Sort(sortKeys, fields);

			List<string> classes = new List<string>();

			for (int i=0; i<fields.Length; i++)
			{
				string field = fields[i];

				while (prefix != "" && !field.StartsWith(prefix + "."))
				{
					//	Remonte d'un niveau dans la hiérarchie des classes.
					string[] args = prefix.Split('.');
					string last = args[args.Length-1];

					generator.EndBlock();

					prefix = prefix.Substring(0, System.Math.Max(0, prefix.Length-last.Length-1));
					addNewline = true;
				}

				string delta = prefix.Length == 0 ? field : field.Substring(prefix.Length+1);

				if (addNewline)
				{
					buffer.Append(generator.Tabs);
					buffer.Append("\n");
					addNewline = false;
				}

				//	Crée les classes manquantes, si besoin :
				while (delta.IndexOf('.') > -1)
				{
					string[] args = delta.Split('.');
					string elem = args[0];

					generator.BeginBlock("public static class", elem);
					classes.Add(elem);

					buffer.Append(generator.Tabs);
					buffer.Append("internal static void _Initialize() { }\n");
					buffer.Append(generator.Tabs);
					buffer.Append("\n");

					if (prefix.Length == 0)
					{
						prefix = elem;
					}
					else
					{
						prefix = string.Concat(prefix, ".", elem);
					}

					delta = field.Substring(prefix.Length + 1);
				}

				//	Crée l'accesseur pour le champ actuel :
				buffer.Append(generator.Tabs);

				Support.Druid druid = bundle[field].Druid;

				buffer.Append("public static readonly Epsitec.Common.Widgets.Command ");
				buffer.Append(delta);
				buffer.Append(@" = Epsitec.Common.Widgets.Command.Get(Epsitec.Common.Support.Druid.FromLong(Epsitec.Common.Support.Druid.FromModuleDruid(_moduleId, ");
				buffer.Append(druid.ToFieldId());
				buffer.Append(")));\n");
			}

			//	Referme les classes ouvertes :
			if (prefix.Length > 0)
			{
				string[] args = prefix.Split('.');

				for (int j=0; j<args.Length; j++)
				{
					generator.EndBlock();
				}
			}
			buffer.Append(generator.Tabs);
			buffer.Append("\n");

			generator.BeginBlock("internal static void", "_Initialize()");
			for (int i=0; i<classes.Count; i++)
			{
				buffer.Append(generator.Tabs);

#if true
				buffer.Append("// plantée à l'initialisation, sans ce commentaire !  ");
#endif

				for (int j=0; j<=i; j++)
				{
					buffer.Append(classes[j]);
					buffer.Append(".");
				}

				buffer.Append("_Initialize();\n");
			}
			generator.EndBlock();

			generator.EndBlock();
		}

		static void GenerateCaptions(ResourceManager manager, System.Text.StringBuilder buffer, Generator generator, string defaultNamespace, string bundleId, ResourceBundle bundle, List<string> capFields)
		{
			string prefix   = "";
			bool addNewline = false;

			generator.BeginBlock("public static class", "Captions");

			string[] fields   = new string[capFields.Count];
			string[] sortKeys = new string[capFields.Count];

			for (int i=0; i<fields.Length; i++)
			{
				fields[i] = capFields[i];

				int pos = fields[i].LastIndexOf('.');
				if (pos < 0)
				{
					sortKeys[i] = fields[i];
				}
				else
				{
					sortKeys[i] = string.Concat(fields[i].Substring(0, pos), "!", fields[i].Substring(pos+1));
				}
			}

			System.Array.Sort(sortKeys, fields);

			for (int i=0; i<fields.Length; i++)
			{
				string field = fields[i];

				while (prefix != "" && !field.StartsWith(prefix + "."))
				{
					//	Remonte d'un niveau dans la hiérarchie des classes.
					string[] args = prefix.Split('.');
					string last = args[args.Length-1];

					generator.EndBlock();

					prefix = prefix.Substring(0, System.Math.Max(0, prefix.Length-last.Length-1));
					addNewline = true;
				}

				string delta = prefix.Length == 0 ? field : field.Substring(prefix.Length+1);

				if (addNewline)
				{
					buffer.Append(generator.Tabs);
					buffer.Append("\n");
					addNewline = false;
				}

				//	Crée les classes manquantes, si besoin :
				while (delta.IndexOf('.') > -1)
				{
					string[] args = delta.Split('.');
					string elem = args[0];

					generator.BeginBlock("public static class", elem);

					if (prefix.Length == 0)
					{
						prefix = elem;
					}
					else
					{
						prefix = string.Concat(prefix, ".", elem);
					}

					delta = field.Substring(prefix.Length + 1);
				}

				//	Crée l'accesseur pour le champ actuel :
				buffer.Append(generator.Tabs);

				Support.Druid druid = bundle[field].Druid;

				buffer.Append("public static Epsitec.Common.Types.Caption ");
				buffer.Append(delta);
				buffer.Append(@" { get { return _manager.GetCaption(Epsitec.Common.Support.Druid.FromLong(Epsitec.Common.Support.Druid.FromModuleDruid(_moduleId, ");
				buffer.Append(druid.ToFieldId());
				buffer.Append("))); } }\n");
			}

			//	Referme les classes ouvertes :
			if (prefix.Length > 0)
			{
				string[] args = prefix.Split('.');

				for (int j=0; j<args.Length; j++)
				{
					generator.EndBlock();
				}
			}
			buffer.Append(generator.Tabs);
			buffer.Append("\n");

			generator.EndBlock();
		}

		static void GenerateTypes(ResourceManager manager, System.Text.StringBuilder buffer, Generator generator, string defaultNamespace, string bundleId, ResourceBundle bundle, List<string> typFields)
		{
			//	TODO: ...
		}
		
		static void GenerateStrings(ResourceManager manager, System.Text.StringBuilder buffer, Generator generator, string defaultNamespace, string bundleId, ResourceBundle bundle)
		{
			string prefix   = "";
			bool addNewline = false;

			generator.BeginBlock ("public static class", bundleId);

			string[] fields   = bundle.FieldNames;
			string[] sortKeys = new string[fields.Length];

			for (int i = 0; i < fields.Length; i++)
			{
				int pos = fields[i].LastIndexOf ('.');

				if (pos < 0)
				{
					sortKeys[i] = fields[i];
				}
				else
				{
					sortKeys[i] = string.Concat (fields[i].Substring (0, pos), "!", fields[i].Substring (pos+1));
				}
			}

			System.Array.Sort (sortKeys, fields);

			for (int i = 0; i < fields.Length; i++)
			{
				string field = fields[i];

				while ((prefix != "") && (field.StartsWith (prefix + ".") == false))
				{
					//	Remonte d'un niveau dans la hiérarchie des classes.

					string[] args = prefix.Split ('.');
					string last = args[args.Length-1];

					generator.EndBlock ();

					prefix = prefix.Substring (0, System.Math.Max (0, prefix.Length - last.Length - 1));
					addNewline = true;
				}

				string delta = prefix.Length == 0 ? field : field.Substring (prefix.Length + 1);

				if (addNewline)
				{
					buffer.Append (generator.Tabs);
					buffer.Append ("\n");
					addNewline = false;
				}

				//	Crée les classes manquantes, si besoin :

				while (delta.IndexOf ('.') > -1)
				{
					string[] args = delta.Split ('.');
					string elem = args[0];

					generator.BeginBlock ("public static class", elem);

					if (prefix.Length == 0)
					{
						prefix = elem;
					}
					else
					{
						prefix = string.Concat (prefix, ".", elem);
					}

					delta = field.Substring (prefix.Length + 1);
				}

				//	Crée l'accesseur pour le champ actuel :

				buffer.Append (generator.Tabs);

				Support.Druid druid = bundle[field].Druid;

				buffer.Append ("public static string ");
				buffer.Append (delta);
				buffer.Append (@" { get { return ");
				buffer.Append (defaultNamespace);
				buffer.Append (@".Res.");
				buffer.Append (bundleId);
				buffer.Append (@".GetText (");

				if (druid.Type == Support.DruidType.ModuleRelative)
				{
					buffer.Append (@"Epsitec.Common.Support.Druid.FromFieldId (");
					buffer.Append (druid.ToFieldId ());
					buffer.Append (@")");
				}
				else
				{
					buffer.Append (@"""");
					buffer.Append (bundleId);
					buffer.Append (@"""");
					
					string[] elems = field.Split ('.');

					for (int k = 0; k < elems.Length; k++)
					{
						buffer.Append (@", """);
						buffer.Append (elems[k]);
						buffer.Append (@"""");
					}
				}

				buffer.Append ("); } }\n");
			}

			//	Referme les classes ouvertes :

			if (prefix.Length > 0)
			{
				string[] args = prefix.Split ('.');

				for (int j = 0; j < args.Length; j++)
				{
					generator.EndBlock ();
				}
			}
			buffer.Append (generator.Tabs);
			buffer.Append ("\n");

			generator.BeginBlock ("public static string", "GetString(params string[] path)");

			buffer.Append (generator.Tabs);
			buffer.Append (@"string field = string.Join (""."", path);");
			buffer.Append ("\n");
			buffer.Append (generator.Tabs);
			buffer.Append (@"return _stringsBundle[field].AsString;");
			buffer.Append ("\n");

			generator.EndBlock ();

			buffer.Append (generator.Tabs);
			buffer.Append ("\n");

			buffer.Append (generator.Tabs);
			buffer.Append ("#region Internal Support Code\n");

			generator.BeginBlock ("private static string", "GetText(string bundle, params string[] path)");

			buffer.Append (generator.Tabs);
			buffer.Append (@"string field = string.Join (""."", path);");
			buffer.Append ("\n");
			buffer.Append (generator.Tabs);
			buffer.Append (@"return _stringsBundle[field].AsString;");
			buffer.Append ("\n");

			generator.EndBlock ();

			generator.BeginBlock ("private static string", "GetText(Epsitec.Common.Support.Druid druid)");

			buffer.Append (generator.Tabs);
			buffer.Append (@"return _stringsBundle[druid].AsString;");
			buffer.Append ("\n");

			generator.EndBlock ();

			buffer.Append (generator.Tabs);
			buffer.Append (@"private static Epsitec.Common.Support.ResourceBundle _stringsBundle = _manager.GetBundle (""");
			buffer.Append (bundleId);
			buffer.Append (@""");");
			buffer.Append ("\n");

			buffer.Append (generator.Tabs);
			buffer.Append ("#endregion\n");

			generator.EndBlock ();
		}

		static bool comandsGenerated;
	}
}
