<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FirebirdSql.Data.FirebirdClient</name>
    </assembly>
    <members>
        <member name="T:FirebirdSql.Data.Isql.CommandExecutingEventArgs">
            <summary>
            CommandExecutingEventArgs encapsulates the events arguments for the event trigged 
            from the <see cref="T:FirebirdSql.Data.Isql.FbBatchExecution"/> during the execution. 
            </summary>
            <remarks>
            
            </remarks>
        </member>
        <member name="M:FirebirdSql.Data.Isql.CommandExecutingEventArgs.#ctor(FirebirdSql.Data.FirebirdClient.FbCommand)">
            <summary>
            Creates an instance of CommandExecutingEventArgs class.
            </summary>
            <param name="sqlCommand">The FbCommand properly instanciated.</param>
            <remarks>The <b>sqlCommand</b> should be proper instanciated with a valid 
            <see cref="T:FirebirdSql.Data.FirebirdClient.FbCommand"/> and with the SQL statement loaded in <see cref="P:FirebirdSql.Data.FirebirdClient.FbCommand.CommandText"/>.
            </remarks>
        </member>
        <member name="M:FirebirdSql.Data.Isql.CommandExecutingEventArgs.ToString">
            <summary>
            Overrided. Returns the SQL statement that goes for execution.
            </summary>
            <returns>The SQL statement that will be executed.</returns>
        </member>
        <member name="P:FirebirdSql.Data.Isql.CommandExecutingEventArgs.SqlCommand">
            <summary>
            Returns the <see cref="T:FirebirdSql.Data.FirebirdClient.FbCommand"/> instance that created for the SQL statement that goes 
            for execution. 
            </summary>
        </member>
        <member name="P:FirebirdSql.Data.Isql.CommandExecutingEventArgs.StatementType">
            <summary>
            Returns the <see cref="T:FirebirdSql.Data.Isql.SqlStatementType"/> of the current <see cref="P:FirebirdSql.Data.Isql.CommandExecutingEventArgs.SqlCommand"/>.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Client.Managed.Version10.GdsDatabase.DatabaseInfo(System.Byte[],System.Byte[],System.Int32)">
            <summary>
            isc_database_info
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.FirebirdClient.FbProviderManifest.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="manifestToken">A token used to infer the capabilities of the store</param>
        </member>
        <member name="M:FirebirdSql.Data.FirebirdClient.FbProviderManifest.GetDbInformation(System.String)">
            <summary>
            Providers should override this to return information specific to their provider.  
            
            This method should never return null.
            </summary>
            <param name="informationType">The name of the information to be retrieved.</param>
            <returns>An XmlReader at the begining of the information requested.</returns>
        </member>
        <member name="M:FirebirdSql.Data.FirebirdClient.FbProviderManifest.GetEdmType(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            This method takes a type and a set of facets and returns the best mapped equivalent type 
            in EDM.
            </summary>
            <param name="storeType">A TypeUsage encapsulating a store type and a set of facets</param>
            <returns>A TypeUsage encapsulating an EDM type and a set of facets</returns>
        </member>
        <member name="M:FirebirdSql.Data.FirebirdClient.FbProviderManifest.GetStoreType(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            This method takes a type and a set of facets and returns the best mapped equivalent type 
            in SQL Server, taking the store version into consideration.
            </summary>
            <param name="storeType">A TypeUsage encapsulating an EDM type and a set of facets</param>
            <returns>A TypeUsage encapsulating a store type and a set of facets</returns>
        </member>
        <member name="T:FirebirdSql.Data.Entity.FirstClause">
            <summary>
            FirstClause represents the FIRST expression in a SqlSelectStatement. 
            It has a count property, which indicates how many FIRST rows should be selected and a 
            boolen WithTies property.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Entity.ISqlFragment">
            <summary>
            Represents the sql fragment for any node in the query tree.
            </summary>
            <remarks>
            The nodes in a query tree produce various kinds of sql
            <list type="bullet">
            <item>A select statement.</item>
            <item>A reference to an extent. (symbol)</item>
            <item>A raw string.</item>
            </list>
            We have this interface to allow for a common return type for the methods
            in the expression visitor <see cref="!:ExpressionVisitor&lt;T&gt;"/>
            
            At the end of translation, the sql fragments are converted into real strings.
            </remarks>
        </member>
        <member name="M:FirebirdSql.Data.Entity.ISqlFragment.WriteSql(FirebirdSql.Data.Entity.SqlWriter,FirebirdSql.Data.Entity.SqlGenerator)">
            <summary>
            Write the string represented by this fragment into the stream.
            </summary>
            <param name="writer">The stream that collects the strings.</param>
            <param name="sqlGenerator">Context information used for renaming.
            The global lists are used to generated new names without collisions.</param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.FirstClause.#ctor(FirebirdSql.Data.Entity.ISqlFragment)">
            <summary>
            Creates a FirstClause with the given topCount and withTies.
            </summary>
            <param name="topCount"></param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.FirstClause.#ctor(System.Int32)">
            <summary>
            Creates a TopClause with the given topCount and withTies.
            </summary>
            <param name="topCount"></param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.FirstClause.WriteSql(FirebirdSql.Data.Entity.SqlWriter,FirebirdSql.Data.Entity.SqlGenerator)">
            <summary>
            Write out the FIRST part of sql select statement 
            It basically writes FIRST (X).
            </summary>
            <param name="writer"></param>
            <param name="sqlGenerator"></param>
        </member>
        <member name="P:FirebirdSql.Data.Entity.FirstClause.FirstCount">
            <summary>
            How many first rows should be selected.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Entity.ExpressionTranslator">
            <summary>
            Lightweight expression translator for DML expression trees, which have constrained
            scope and support.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.ExpressionTranslator.#ctor(System.Text.StringBuilder,System.Data.Common.CommandTrees.DbModificationCommandTree,System.Boolean)">
            <summary>
            Initialize a new expression translator populating the given string builder
            with command text. Command text builder and command tree must not be null.
            </summary>
            <param name="commandText">Command text with which to populate commands</param>
            <param name="commandTree">Command tree generating SQL</param>
            <param name="preserveMemberValues">Indicates whether the translator should preserve
            member values while compiling t-SQL (only needed for server generation)</param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.ExpressionTranslator.RegisterMemberValue(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            Call this method to register a property value pair so the translator "remembers"
            the values for members of the row being modified. These values can then be used
            to form a predicate for server-generation (based on the key of the row)
            </summary>
            <param name="propertyExpression">Expression containing the column reference (property expression).</param>
            <param name="value">Expression containing the value of the column.</param>
        </member>
        <member name="M:FirebirdSql.Data.Common.IscException.#ctor(System.String,System.Int32)">
            <param name="dummy">This parameter is here only to differentiate sqlState and strParam.</param>
        </member>
        <member name="T:FirebirdSql.Data.Entity.JoinSymbol">
            <summary>
            A Join symbol is a special kind of Symbol.
            It has to carry additional information
            <list type="bullet">
            <item>ColumnList for the list of columns in the select clause if this
            symbol represents a sql select statement.  This is set by <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.AddDefaultColumns(FirebirdSql.Data.Entity.SqlSelectStatement)"/>. </item>
            <item>ExtentList is the list of extents in the select clause.</item>
            <item>FlattenedExtentList - if the Join has multiple extents flattened at the 
            top level, we need this information to ensure that extent aliases are renamed
            correctly in <see cref="M:FirebirdSql.Data.Entity.SqlSelectStatement.WriteSql(FirebirdSql.Data.Entity.SqlWriter,FirebirdSql.Data.Entity.SqlGenerator)"/></item>
            <item>NameToExtent has all the extents in ExtentList as a dictionary.
            This is used by <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbPropertyExpression)"/> to flatten
            record accesses.</item>
            <item>IsNestedJoin - is used to determine whether a JoinSymbol is an 
            ordinary join symbol, or one that has a corresponding SqlSelectStatement.</item>
            </list>
            
            All the lists are set exactly once, and then used for lookups/enumerated.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Entity.Symbol">
             <summary>
             <see cref="T:FirebirdSql.Data.Entity.SymbolTable"/>
             This class represents an extent/nested select statement,
             or a column.
            
             The important fields are Name, Type and NewName.
             NewName starts off the same as Name, and is then modified as necessary.
            
            
             The rest are used by special symbols.
             e.g. NeedsRenaming is used by columns to indicate that a new name must
             be picked for the column in the second phase of translation.
            
             IsUnnest is used by symbols for a collection expression used as a from clause.
             This allows <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.AddFromSymbol(FirebirdSql.Data.Entity.SqlSelectStatement,System.String,FirebirdSql.Data.Entity.Symbol,System.Boolean)"/> to add the column list
             after the alias.
            
             </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.Symbol.WriteSql(FirebirdSql.Data.Entity.SqlWriter,FirebirdSql.Data.Entity.SqlGenerator)">
             <summary>
             Write this symbol out as a string for sql.  This is just
             the new name of the symbol (which could be the same as the old name).
            
             We rename columns here if necessary.
             </summary>
             <param name="writer"></param>
             <param name="sqlGenerator"></param>
        </member>
        <member name="T:FirebirdSql.Data.Isql.StringParser">
             <summary>
             StringParser parses a string returnning the (sub)strings between tokens.
             </summary>
             <example>
             An example of how to use this class.
             <code>
             [STAThread]
             static void Main(string[] args) {
            		int currentIndex = 0;
            		string s = ".NET Framework doesn't have a string parsing class?!";
            		StringParser parser = new StringParser(s, false);			
            		while (currentIndex &lt; s.Length) {
            			Console.WriteLine("Returned Index: {0}", currentIndex = parser.ParseNext());
            			Console.WriteLine("Chars scanned: {0}", parser.CharsParsed);
            			Console.WriteLine("Parsing result: {0}", parser.Result);
            			Console.WriteLine();     
            		}
             }
             </code>
             <para>The output:</para>
             <code>
             Returned Index: 5
            	Chars scanned: 5
            	Parsing	result:	.NET
            
            	Returned Index:	15
            	Chars scanned: 10
            	Parsing	result:	Framework
            
            	Returned Index:	23
            	Chars scanned: 8
            	Parsing	result:	doesn't
            
            	Returned Index:	28
            	Chars scanned: 5
            	Parsing	result:	have
            
            	Returned Index:	30
            	Chars scanned: 2
            	Parsing	result:	a
            
            	Returned Index:	37
            	Chars scanned: 7
            	Parsing	result:	string
            
            	Returned Index:	45
            	Chars scanned: 8
            	Parsing	result:	parsing
            
            	Returned Index:	52
            	Chars scanned: 7
            	Parsing	result:	class?!
             </code>
             </example>
        </member>
        <member name="M:FirebirdSql.Data.Isql.StringParser.#ctor(System.Boolean)">
            <summary>
            Creates an instance of StringParser.
            </summary>
            <param name="caseSensitive">Indicates if parser system should be case-sensitive (true) or case-intensitive (false).</param>
        </member>
        <member name="M:FirebirdSql.Data.Isql.StringParser.#ctor(System.String,System.Boolean)">
            <summary>
            Creates an instance of StringParser.
            </summary>
            <param name="targetString">Indicates if parser system should be case-sensitive (true) or case-intensitive (false).</param>
            <param name="caseSensitive">The string to parse.</param>
            <remarks>By defining the string (to parse) in constructor you can call directly the method <see cref="M:FirebirdSql.Data.Isql.StringParser.ParseNext"/>
            without having to initializate the target string on <see cref="M:FirebirdSql.Data.Isql.StringParser.Parse(System.String)"/> method. See the example for further details.
            </remarks>
        </member>
        <member name="M:FirebirdSql.Data.Isql.StringParser.Parse(System.String)">
            <summary>
            Parses target string attempting to determine the (sub)string between the beginning of this string and the <see cref="P:FirebirdSql.Data.Isql.StringParser.Token"/>.
            After the parse is complete system will load into <see cref="P:FirebirdSql.Data.Isql.StringParser.CharsParsed"/> then number of chars scanned and into <see cref="P:FirebirdSql.Data.Isql.StringParser.Result"/>
            the string that was found.
            </summary>
            <param name="targetString">The string to be parsed.</param>
            <returns>The index of the char next char after the <see cref="P:FirebirdSql.Data.Isql.StringParser.Token"/> end.</returns>
            <remarks>If nothing is parsed the method will return -1. Case the <see cref="P:FirebirdSql.Data.Isql.StringParser.Token"/> wasn't found until the end of the string the method retuns 
            (in <see cref="P:FirebirdSql.Data.Isql.StringParser.Result"/>) the string found between the starting index and the end of the string. </remarks>
        </member>
        <member name="M:FirebirdSql.Data.Isql.StringParser.Parse(System.String,System.Int32)">
            <summary>
            Parses target string attempting to determine the (sub)string between the index <b>start</b> of this string and the <see cref="P:FirebirdSql.Data.Isql.StringParser.Token"/>.
            After the parse is complete system will load into <see cref="P:FirebirdSql.Data.Isql.StringParser.CharsParsed"/> then number of chars scanned and into <see cref="P:FirebirdSql.Data.Isql.StringParser.Result"/>
            the string that was found.
            </summary>
            <param name="targetString">The string to be parsed.</param>
            <param name="start">The start index for parsing purposes.</param>
            <returns>The index of the char next char after the <c>Token</c> end.</returns>
            <remarks>If nothing is parsed the method will return -1. Case the <see cref="P:FirebirdSql.Data.Isql.StringParser.Token"/> wasn't found until the end of the string the method returns 
            (in <see cref="P:FirebirdSql.Data.Isql.StringParser.Result"/>) the string found between the starting index and the end of the string. </remarks>
        </member>
        <member name="M:FirebirdSql.Data.Isql.StringParser.ParseNext">
            <summary>
            <para>
            Repeats the parsing starting on the index returned by <see cref="M:FirebirdSql.Data.Isql.StringParser.Parse(System.String)"/> method.</para>
            You can also call <b>ParseNext</b> directly (without calling <see cref="M:FirebirdSql.Data.Isql.StringParser.Parse(System.String)"/>) if you define the text to be parsed at instance construction.  
            </summary>
            <returns>The index of the char next char after the <see cref="P:FirebirdSql.Data.Isql.StringParser.Token"/> end.</returns>
            <remarks>If nothing is parsed the method will return -1. Case the <see cref="P:FirebirdSql.Data.Isql.StringParser.Token"/> wasn't found until the end of the string the method returns 
            (in <see cref="P:FirebirdSql.Data.Isql.StringParser.Result"/>) the string found between the starting index and the end of the string.</remarks>
        </member>
        <member name="M:FirebirdSql.Data.Isql.StringParser.IndexOf(System.String)">
            <summary>
            Returns the index of the substring in the string. If the substring does not exists the method returns <b>-1</b>.
            </summary>
            <param name="substring">The string to be located.</param>
            <returns>The index of the substring or -1 if the string does not exists within the source string.
            If the the substring is empty method returns 0.</returns>
            <remarks>The instance parses for the substring in a case sensitive or intensive way, as you specify at 
            class construction.</remarks>
        </member>
        <member name="M:FirebirdSql.Data.Isql.StringParser.IndexOf(System.String,System.Int32)">
            <summary>
            Returns the index of the substring in the string starting on index <b>startIndex</b>. 
            If the substring does not exists the method returns <b>-1</b>.
            </summary>
            <param name="substring">The string to be located.</param>
            <param name="startIndex">The start index of the source string where parser will start.</param>
            <returns>The index of the substring or -1 if the string does not exists within the source string.
            If the the substring is empty method returns <i>startIndex</i>.</returns>
            <remarks>The instance parses for the substring in a case sensitive or intensive way, as you specify at 
            class construction.</remarks>
        </member>
        <member name="M:FirebirdSql.Data.Isql.StringParser.ToString">
            <summary>
            Overrided method that returns the string to be parsed.
            </summary>
            <returns>The string to be parsed.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Isql.StringParser.StartsWith(System.String,System.String,System.Boolean)">
            <summary>
            Indicates if the string specified as <b>source</b> starts with the <b>token</b> string.
            </summary>
            <param name="source">The source string.</param>
            <param name="token">The token that is intended to find.</param>
            <param name="ignoreCase">Indicated is char case should be ignored.</param>
            <returns>Returns <b>true</b> if the <b>token</b> precedes the <b>source</b>.</returns>
        </member>
        <member name="P:FirebirdSql.Data.Isql.StringParser.CharsParsed">
            <summary>
            Loaded after a parsing operation with the number of chars parsed.
            </summary>
        </member>
        <member name="P:FirebirdSql.Data.Isql.StringParser.Result">
            <summary>
            Loaded after a parsing operation with the string that was found between tokens.
            </summary>
        </member>
        <member name="P:FirebirdSql.Data.Isql.StringParser.Token">
            <summary>
            The string separator. The default value is a white space: 0x32 ASCII code.
            </summary>
        </member>
        <member name="P:FirebirdSql.Data.Isql.StringParser.Length">
            <summary>
            Returns the length of the string that is being parsed.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Isql.CommandExecutedEventHandler">
            <summary>
            The event handler type trigged after a SQL statement execution.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Entity.SkipClause">
            <summary>
            SkipClause represents the SKIP expression in a SqlSelectStatement. 
            It has a count property, which indicates how many rows should be skipped.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SkipClause.#ctor(FirebirdSql.Data.Entity.ISqlFragment)">
            <summary>
            Creates a SkipClause with the given skipCount.
            </summary>
            <param name="topCount"></param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SkipClause.#ctor(System.Int32)">
            <summary>
            Creates a SkipClause with the given skipCount.
            </summary>
            <param name="topCount"></param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SkipClause.WriteSql(FirebirdSql.Data.Entity.SqlWriter,FirebirdSql.Data.Entity.SqlGenerator)">
            <summary>
            Write out the SKIP part of sql select statement 
            It basically writes SKIP (X).
            </summary>
            <param name="writer"></param>
            <param name="sqlGenerator"></param>
        </member>
        <member name="P:FirebirdSql.Data.Entity.SkipClause.SkipCount">
            <summary>
            How many rows should be skipped.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Isql.SqlStatementType">
            <summary>
            DSQL and ISQL statement types.
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.AlterDatabase">
            <summary>
            Represents the SQL statement: <b>ALTER DATABASE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.AlterDomain">
            <summary>
            Represents the SQL statement: <b>ALTER DOMAIN</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.AlterException">
            <summary>
            Represents the SQL statement: <b>ALTER EXCEPTION</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.AlterIndex">
            <summary>
            Represents the SQL statement: <b>ALTER INDEX</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.AlterProcedure">
            <summary>
            Represents the SQL statement: <b>ALTER PROCEDURE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.AlterSequence">
            <summary>
            Represents the SQL statement: <b>ALTER SEQUENCE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.AlterTable">
            <summary>
            Represents the SQL statement: <b>ALTER TABLE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.AlterTrigger">
            <summary>
            Represents the SQL statement: <b>ALTER TRIGGER</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Close">
            <summary>
            Represents the SQL statement: <b>CLOSE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.CommentOn">
            <summary>
            Represents the SQL statement: <b>COMMENT ON</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Commit">
            <summary>
            Represents the SQL statement: <b>COMMIT</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Connect">
            <summary>
            Represents the SQL statement: <b>CONNECT</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.CreateDatabase">
            <summary>
            Represents the SQL statement: <b>CREATE DATABASE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.CreateDomain">
            <summary>
            Represents the SQL statement: <b>CREATE DOMAIN</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.CreateException">
            <summary>
            Represents the SQL statement: <b>CREATE EXCEPTION</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.CreateGenerator">
            <summary>
            Represents the SQL statement: <b>CREATE GENERATOR</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.CreateIndex">
            <summary>
            Represents the SQL statement: <b>CREATE INDEX</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.CreateProcedure">
            <summary>
            Represents the SQL statement: <b>CREATE PROCEDURE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.CreateRole">
            <summary>
            Represents the SQL statement: <b>CREATE ROLE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.CreateSequence">
            <summary>
            Represents the SQL statement: <b>CREATE SEQUENCE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.CreateShadow">
            <summary>
            Represents the SQL statement: <b>CREATE SHADOW</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.CreateTable">
            <summary>
            Represents the SQL statement: <b>CREATE TABLE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.CreateTrigger">
            <summary>
            Represents the SQL statement: <b>CREATE TRIGGER</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.CreateView">
            <summary>
            Represents the SQL statement: <b>CREATE VIEW</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DeclareCursor">
            <summary>
            Represents the SQL statement: <b>DECLARE CURSOR</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DeclareExternalFunction">
            <summary>
            Represents the SQL statement: <b>DECLARE EXTERNAL FUNCTION</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DeclareFilter">
            <summary>
            Represents the SQL statement: <b>DECLARE FILTER</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DeclareStatement">
            <summary>
            Represents the SQL statement: <b>DECLARE STATEMENT</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DeclareTable">
            <summary>
            Represents the SQL statement: <b>DECLARE TABLE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Delete">
            <summary>
            Represents the SQL statement: <b>DELETE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Describe">
            <summary>
            Represents the SQL statement: <b>DESCRIBE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Disconnect">
            <summary>
            Represents the SQL statement: <b>DISCONNECT</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DropDatabase">
            <summary>
            Represents the SQL statement: <b>DROP DATABASE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DropDomain">
            <summary>
            Represents the SQL statement: <b>DROP DOMAIN</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DropException">
            <summary>
            Represents the SQL statement: <b>DROP EXCEPTION</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DropExternalFunction">
            <summary>
            Represents the SQL statement: <b>DROP EXTERNAL FUNCTION</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DropFilter">
            <summary>
            Represents the SQL statement: <b>DROP FILTER</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DropGenerator">
            <summary>
            Represents the SQL statement: <b>DROP GENERATOR</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DropIndex">
            <summary>
            Represents the SQL statement: <b>DROP INDEX</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DropProcedure">
            <summary>
            Represents the SQL statement: <b>DROP PROCEDURE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DropSequence">
            <summary>
            Represents the SQL statement: <b>DROP SEQUENCE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DropRole">
            <summary>
            Represents the SQL statement: <b>DROP ROLE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DropShadow">
            <summary>
            Represents the SQL statement: <b>DROP SHADOW</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DropTable">
            <summary>
            Represents the SQL statement: <b>DROP TABLE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DropTrigger">
            <summary>
            Represents the SQL statement: <b>DROP TRIGGER</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.DropView">
            <summary>
            Represents the SQL statement: <b>DROP VIEW</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.EndDeclareSection">
            <summary>
            Represents the SQL statement: <b>END DECLARE SECTION</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.EventInit">
            <summary>
            Represents the SQL statement: <b>EVENT INIT</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.EventWait">
            <summary>
            Represents the SQL statement: <b>EVENT WAIT</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Execute">
            <summary>
            Represents the SQL statement: <b>EXECUTE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.ExecuteImmediate">
            <summary>
            Represents the SQL statement: <b>EXECUTE IMMEDIATE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.ExecuteProcedure">
            <summary>
            Represents the SQL statement: <b>EXECUTE PROCEDURE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Fetch">
            <summary>
            Represents the SQL statement: <b>FETCH</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Grant">
            <summary>
            Represents the SQL statement: <b>GRANT</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Insert">
            <summary>
            Represents the SQL statement: <b>INSERT</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.InsertCursor">
            <summary>
            Represents the SQL statement: <b>INSERT CURSOR</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Open">
            <summary>
            Represents the SQL statement: <b>OPEN</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Prepare">
            <summary>
            Represents the SQL statement: <b>PREPARE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.RecereateProcedure">
            <summary>
            Represents the SQL statement: <b>RECREATE PROCEDURE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.RecreateTable">
            <summary>
            Represents the SQL statement: <b>RECREATE TABLE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.RecreateView">
            <summary>
            Represents the SQL statement: <b>RECREATE VIEW</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Revoke">
            <summary>
            Represents the SQL statement: <b>REVOKE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Rollback">
            <summary>
            Represents the SQL statement: <b>ROLLBACK</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Select">
            <summary>
            Represents the SQL statement: <b>SELECT</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.SetDatabase">
            <summary>
            Represents the SQL statement: <b>SET DATABASE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.SetGenerator">
            <summary>
            Represents the SQL statement: <b>SET GENERATOR</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.SetNames">
            <summary>
            Represents the SQL statement: <b>SET NAMES</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.SetSQLDialect">
            <summary>
            Represents the SQL statement: <b>SET SQL DIALECT</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.SetStatistics">
            <summary>
            Represents the SQL statement: <b>SET STATISTICS</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.SetTransaction">
            <summary>
            Represents the SQL statement: <b>SET TRANSACTION</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.ShowSQLDialect">
            <summary>
            Represents the SQL statement: <b>SHOW SQL DIALECT</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Update">
            <summary>
            Represents the SQL statement: <b>UPDATE</b>
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Isql.SqlStatementType.Whenever">
            <summary>
            Represents the SQL statement: <b>WHENEVER</b>
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Entity.SymbolTable">
            <summary>
            The symbol table is quite primitive - it is a stack with a new entry for
            each scope.  Lookups search from the top of the stack to the bottom, until
            an entry is found.
            
            The symbols are of the following kinds
            <list type="bullet">
            <item><see cref="T:FirebirdSql.Data.Entity.Symbol"/> represents tables (extents/nested selects/unnests)</item>
            <item><see cref="T:FirebirdSql.Data.Entity.JoinSymbol"/> represents Join nodes</item>
            <item><see cref="T:FirebirdSql.Data.Entity.Symbol"/> columns.</item>
            </list>
            
            Symbols represent names <see cref="!:SqlGenerator.Visit(VariableReferenceExpression)"/> to be resolved, 
            or things to be renamed.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Entity.SqlWriter">
            <summary>
            This extends StringWriter primarily to add the ability to add an indent
            to each line that is written out.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlWriter.#ctor(System.Text.StringBuilder)">
            <summary>
            
            </summary>
            <param name="b"></param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlWriter.Write(System.String)">
            <summary>
            Reset atBeginningofLine if we detect the newline string.
            <see cref="M:FirebirdSql.Data.Entity.SqlBuilder.AppendLine"/>
            Add as many tabs as the value of indent if we are at the 
            beginning of a line.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlWriter.WriteLine">
            <summary>
            Writes a line terminator to the text stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.TextWriter"/> is closed. </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
        </member>
        <member name="P:FirebirdSql.Data.Entity.SqlWriter.Indent">
            <summary>
            The number of tabs to be added at the beginning of each new line.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.FirebirdClient.FbDataAdapter.Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)">
            <summary>
            Review .NET	Framework documentation.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Client.Native.IFbClient">
            <summary>
            This is the interface that the dynamically-generated class uses to call the native library.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Isql.FbScript">
            <summary>
            FbScript parses a SQL file and returns its SQL statements. 
            The class take in consideration that the statement separator can change in code. 
            For instance, in Firebird databases the statement <c>SET TERM !! ;</c> will change the
            statement token terminator <b>;</b> into <b>!!</b>.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbScript.LoadFromFile(System.String)">
            <summary>
            Creates FbScript reading content from file.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbScript.Parse">
            <summary>
            Parses the SQL code and loads the SQL statements into the StringCollection <see cref="P:FirebirdSql.Data.Isql.FbScript.Results"/>.
            </summary>
            <returns>The number of statements found.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbScript.ToString">
            <summary>
            Overrided method, returns the the SQL code to be parsed (with comments removed).
            </summary>
            <returns>The SQL code to be parsed (without comments).</returns>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbScript.RemoveComments(System.String)">
            <summary>
            Removes from the SQL code all comments of the type: /*...*/ or --
            </summary>
            <param name="source">The string containing the original SQL code.</param>
            <returns>A string containing the SQL code without comments.</returns>
        </member>
        <member name="P:FirebirdSql.Data.Isql.FbScript.Results">
            <summary>
            Returns a FbStatementCollection containing all the SQL statements (without comments) present on the file.
            This property is loaded after the method call <see cref="M:FirebirdSql.Data.Isql.FbScript.Parse"/>.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Common.Descriptor">
            <summary>
            Descriptor of query input and output parameters.
            </summary>
            <remarks>
            This is similar to the XSQLDA structure described 
            in the Interbase 6.0 API docs.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:FirebirdSql.Data.Entity.SqlSelectStatement" -->
        <member name="M:FirebirdSql.Data.Entity.SqlSelectStatement.WriteSql(FirebirdSql.Data.Entity.SqlWriter,FirebirdSql.Data.Entity.SqlGenerator)">
            <summary>
            Write out a SQL select statement as a string.
            We have to
            <list type="number">
            <item>Check whether the aliases extents we use in this statement have
            to be renamed.
            We first create a list of all the aliases used by the outer extents.
            For each of the FromExtents( or AllJoinExtents if it is non-null),
            rename it if it collides with the previous list.
            </item>
            <item>Write each of the clauses (if it exists) as a string</item>
            </list>
            </summary>
            <param name="writer"></param>
            <param name="sqlGenerator"></param>
        </member>
        <member name="P:FirebirdSql.Data.Entity.SqlSelectStatement.IsDistinct">
            <summary>
            Do we need to add a DISTINCT at the beginning of the SELECT
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Isql.CommandExecutingEventHandler">
            <summary>
            The event handler type trigged before a SQL statement execution.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.FirebirdClient.FbProviderServices.CreateCommand(System.Data.Common.DbProviderManifest,System.Data.Common.CommandTrees.DbCommandTree)">
            <summary>
            Create a SampleCommand object, given the provider manifest and command tree
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.FirebirdClient.FbProviderServices.CreateSqlParameter(System.String,System.Data.Metadata.Edm.TypeUsage,System.Data.Metadata.Edm.ParameterMode,System.Object)">
            <summary>
            Creates a SqlParameter given a name, type, and direction
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.FirebirdClient.FbProviderServices.GetSqlDbType(System.Data.Metadata.Edm.TypeUsage,System.Boolean,System.Nullable{System.Int32}@)">
            <summary>
            Determines SqlDbType for the given primitive type. Extracts facet
            information as well.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.FirebirdClient.FbProviderServices.GetParameterSize(System.Data.Metadata.Edm.TypeUsage,System.Boolean)">
            <summary>
            Determines preferred value for SqlParameter.Size. Returns null
            where there is no preference.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.FirebirdClient.FbProviderServices.GetStringDbType(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Chooses the appropriate FbDbType for the given string type.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.FirebirdClient.FbProviderServices.GetBinaryDbType(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Chooses the appropriate FbDbType for the given binary type.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Entity.SqlGenerator">
             <summary>
             Translates the command object into a SQL string that can be executed on
             SQL Server 2005.
             </summary>
             <remarks>
             The translation is implemented as a visitor <see cref="T:System.Data.Common.CommandTrees.DbExpressionVisitor`1"/>
             over the query tree.  It makes a single pass over the tree, collecting the sql
             fragments for the various nodes in the tree <see cref="T:FirebirdSql.Data.Entity.ISqlFragment"/>.
            
             The major operations are
             <list type="bullet">
             <item>Select statement minimization.  Multiple nodes in the query tree
             that can be part of a single SQL select statement are merged. e.g. a
             Filter node that is the input of a Project node can typically share the
             same SQL statement.</item>
             <item>Alpha-renaming.  As a result of the statement minimization above, there
             could be name collisions when using correlated subqueries
             <example>
             <code>
             Filter(
                 b = Project( c.x
                     c = Extent(foo)
                     )
                 exists (
                     Filter(
                         c = Extent(foo)
                         b.x = c.x
                         )
                 )
             )
             </code>
             The first Filter, Project and Extent will share the same SQL select statement.
             The alias for the Project i.e. b, will be replaced with c.
             If the alias c for the Filter within the exists clause is not renamed,
             we will get <c>c.x = c.x</c>, which is incorrect.
             Instead, the alias c within the second filter should be renamed to c1, to give
             <c>c.x = c1.x</c> i.e. b is renamed to c, and c is renamed to c1.
             </example>
             </item>
             <item>Join flattening.  In the query tree, a list of join nodes is typically
             represented as a tree of Join nodes, each with 2 children. e.g.
             <example>
             <code>
             a = Join(InnerJoin
                 b = Join(CrossJoin
                     c = Extent(foo)
                     d = Extent(foo)
                     )
                 e = Extent(foo)
                 on b.c.x = e.x
                 )
             </code>
             If translated directly, this will be translated to
             <code>
             FROM ( SELECT c.*, d.*
                     FROM foo as c
                     CROSS JOIN foo as d) as b
             INNER JOIN foo as e on b.x' = e.x
             </code>
             It would be better to translate this as
             <code>
             FROM foo as c
             CROSS JOIN foo as d
             INNER JOIN foo as e on c.x = e.x
             </code>
             This allows the optimizer to choose an appropriate join ordering for evaluation.
             </example>
             </item>
             <item>Select * and column renaming.  In the example above, we noticed that
             in some cases we add <c>SELECT * FROM ...</c> to complete the SQL
             statement. i.e. there is no explicit PROJECT list.
             In this case, we enumerate all the columns available in the FROM clause
             This is particularly problematic in the case of Join trees, since the columns
             from the extents joined might have the same name - this is illegal.  To solve
             this problem, we will have to rename columns if they are part of a SELECT *
             for a JOIN node - we do not need renaming in any other situation.
             <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.AddDefaultColumns(FirebirdSql.Data.Entity.SqlSelectStatement)"/>.
             </item>
             </list>
            
             <para>
             Renaming issues.
             When rows or columns are renamed, we produce names that are unique globally
             with respect to the query.  The names are derived from the original names,
             with an integer as a suffix. e.g. CustomerId will be renamed to CustomerId1,
             CustomerId2 etc.
            
             Since the names generated are globally unique, they will not conflict when the
             columns of a JOIN SELECT statement are joined with another JOIN. 
            
             </para>
            
             <para>
             Record flattening.
             SQL server does not have the concept of records.  However, a join statement
             produces records.  We have to flatten the record accesses into a simple
             <c>alias.column</c> form.  <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbPropertyExpression)"/>
             </para>
            
             <para>
             Building the SQL.
             There are 2 phases
             <list type="numbered">
             <item>Traverse the tree, producing a sql builder <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/></item>
             <item>Write the SqlBuilder into a string, renaming the aliases and columns
             as needed.</item>
             </list>
            
             In the first phase, we traverse the tree.  We cannot generate the SQL string
             right away, since
             <list type="bullet">
             <item>The WHERE clause has to be visited before the from clause.</item>
             <item>extent aliases and column aliases need to be renamed.  To minimize
             renaming collisions, all the names used must be known, before any renaming
             choice is made.</item>
             </list>
             To defer the renaming choices, we use symbols <see cref="T:FirebirdSql.Data.Entity.Symbol"/>.  These
             are renamed in the second phase.
            
             Since visitor methods cannot transfer information to child nodes through
             parameters, we use some global stacks,
             <list type="bullet">
             <item>A stack for the current SQL select statement.  This is needed by
             <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbVariableReferenceExpression)"/> to create a
             list of free variables used by a select statement.  This is needed for
             alias renaming.
             </item>
             <item>A stack for the join context.  When visiting a <see cref="T:System.Data.Common.CommandTrees.DbScanExpression"/>,
             we need to know whether we are inside a join or not.  If we are inside
             a join, we do not create a new SELECT statement.</item>
             </list>
             </para>
            
             <para>
             Global state.
             To enable renaming, we maintain
             <list type="bullet">
             <item>The set of all extent aliases used.</item>
             <item>The set of all column aliases used.</item>
             </list>
            
             Finally, we have a symbol table to lookup variable references.  All references
             to the same extent have the same symbol.
             </para>
            
             <para>
             Sql select statement sharing.
            
             Each of the relational operator nodes
             <list type="bullet">
             <item>Project</item>
             <item>Filter</item>
             <item>GroupBy</item>
             <item>Sort/OrderBy</item>
             </list>
             can add its non-input (e.g. project, predicate, sort order etc.) to
             the SQL statement for the input, or create a new SQL statement.
             If it chooses to reuse the input's SQL statement, we play the following
             symbol table trick to accomplish renaming.  The symbol table entry for
             the alias of the current node points to the symbol for the input in
             the input's SQL statement.
             <example>
             <code>
             Project(b.x
                 b = Filter(
                     c = Extent(foo)
                     c.x = 5)
                 )
             </code>
             The Extent node creates a new SqlSelectStatement.  This is added to the
             symbol table by the Filter as {c, Symbol(c)}.  Thus, <c>c.x</c> is resolved to
             <c>Symbol(c).x</c>.
             Looking at the project node, we add {b, Symbol(c)} to the symbol table if the
             SQL statement is reused, and {b, Symbol(b)}, if there is no reuse.
            
             Thus, <c>b.x</c> is resolved to <c>Symbol(c).x</c> if there is reuse, and to
             <c>Symbol(b).x</c> if there is no reuse.
             </example>
             </para>
             </remarks>
        </member>
        <member name="F:FirebirdSql.Data.Entity.SqlGenerator.selectStatementStack">
            <summary>
            Every relational node has to pass its SELECT statement to its children
            This allows them (DbVariableReferenceExpression eventually) to update the list of
            outer extents (free variables) used by this select statement.
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Entity.SqlGenerator.isParentAJoinStack">
            <summary>
            Nested joins and extents need to know whether they should create
            a new Select statement, or reuse the parent's.  This flag
            indicates whether the parent is a join or not.
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Entity.SqlGenerator.isVarRefSingle">
            <summary>
            VariableReferenceExpressions are allowed only as children of DbPropertyExpression
            or MethodExpression.  The cheapest way to ensure this is to set the following
            property in DbVariableReferenceExpression and reset it in the allowed parent expressions.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.InitializeBuiltInFunctionHandlers">
            <summary>
            All special built-in functions and their handlers
            </summary>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.InitializeCanonicalFunctionHandlers">
            <summary>
            All special non-aggregate canonical functions and their handlers
            </summary>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.InitializeFunctionNameToOperatorDictionary">
            <summary>
            Initializes the mapping from functions to T-SQL operators
            for all functions that translate to T-SQL operators
            </summary>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.#ctor">
            <summary>
            Basic constructor. 
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.GenerateSql(System.Data.Common.CommandTrees.DbCommandTree,System.Collections.Generic.List{System.Data.Common.DbParameter}@,System.Data.CommandType@)">
            <summary>
            General purpose static function that can be called from System.Data assembly
            </summary>
            <param name="sqlVersion">Server version</param>
            <param name="tree">command tree</param>
            <param name="parameters">Parameters to add to the command tree corresponding
            to constants in the command tree. Used only in ModificationCommandTrees.</param>
            <returns>The string representing the SQL to be executed.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.GenerateSql(System.Data.Common.CommandTrees.DbQueryCommandTree)">
             <summary>
             Translate a command tree to a SQL string.
            
             The input tree could be translated to either a SQL SELECT statement
             or a SELECT expression.  This choice is made based on the return type
             of the expression
             CollectionType => select statement
             non collection type => select expression
             </summary>
             <param name="tree"></param>
             <returns>The string representing the SQL to be executed.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.GenerateFunctionSql(System.Data.Common.CommandTrees.DbFunctionCommandTree,System.Data.CommandType@)">
            <summary>
            Translate a function command tree to a SQL string.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.WriteSql(FirebirdSql.Data.Entity.ISqlFragment)">
            <summary>
            Convert the SQL fragments to a string.
            We have to setup the Stream for writing.
            </summary>
            <param name="sqlStatement"></param>
            <returns>A string representing the SQL to be executed.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbAndExpression)">
            <summary>
            Translate(left) AND Translate(right)
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/>.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbApplyExpression)">
            <summary>
            An apply is just like a join, so it shares the common join processing
            in <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.VisitJoinExpression(System.Collections.Generic.IList{System.Data.Common.CommandTrees.DbExpressionBinding},System.Data.Common.CommandTrees.DbExpressionKind,System.String,System.Data.Common.CommandTrees.DbExpression)"/>
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlSelectStatement"/>.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbArithmeticExpression)">
            <summary>
            For binary expressions, we delegate to <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.VisitBinaryExpression(System.String,System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression)"/>.
            We handle the other expressions directly.
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbCaseExpression)">
            <summary>
            If the ELSE clause is null, we do not write it out.
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbCastExpression)">
             <summary>
            
             </summary>
             <param name="e"></param>
             <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbComparisonExpression)">
            <summary>
            The parser generates Not(Equals(...)) for &lt;&gt;.
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/>.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbConstantExpression)">
            <summary>
            Constants will be send to the store as part of the generated TSQL, not as parameters
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/>.  Strings are wrapped in single
            quotes and escaped.  Numbers are written literally.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbDerefExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbDerefExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbDistinctExpression)">
            <summary>
            The DISTINCT has to be added to the beginning of SqlSelectStatement.Select,
            but it might be too late for that.  So, we use a flag on SqlSelectStatement
            instead, and add the "DISTINCT" in the second phase.
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlSelectStatement"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbElementExpression)">
            <summary>
            An element expression returns a scalar - so it is translated to
            ( Select ... )
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbExceptExpression)">
            <summary>
            <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbUnionAllExpression)"/>
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            Only concrete expression types will be visited.
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbScanExpression)">
             <summary>
            
             </summary>
             <param name="e"></param>
             <returns>If we are in a Join context, returns a <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/>
             with the extent name, otherwise, a new <see cref="T:FirebirdSql.Data.Entity.SqlSelectStatement"/>
             with the From field set.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.GetTargetTSql(System.Data.Metadata.Edm.EntitySetBase)">
            <summary>
            Gets escaped TSql identifier describing this entity set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)">
            <summary>
            The bodies of <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)"/>, <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbGroupByExpression)"/>,
            <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbProjectExpression)"/>, <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbSortExpression)"/> are similar.
            Each does the following.
            <list type="number">
            <item> Visit the input expression</item>
            <item> Determine if the input's SQL statement can be reused, or a new
            one must be created.</item>
            <item>Create a new symbol table scope</item>
            <item>Push the Sql statement onto a stack, so that children can
            update the free variable list.</item>
            <item>Visit the non-input expression.</item>
            <item>Cleanup</item>
            </list>
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlSelectStatement"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Lambda functions are not supported.
            The functions supported are:
            <list type="number">
            <item>Canonical Functions - We recognize these by their dataspace, it is DataSpace.CSpace</item>
            <item>Store Functions - We recognize these by the BuiltInAttribute and not being Canonical</item>
            <item>User-defined Functions - All the rest except for Lambda functions</item>
            </list>
            We handle Canonical and Store functions the same way: If they are in the list of functions 
            that need special handling, we invoke the appropriate handler, otherwise we translate them to
            FunctionName(arg1, arg2, ..., argn).
            We translate user-defined functions to NamespaceName.FunctionName(arg1, arg2, ..., argn).
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbEntityRefExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbEntityRefExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbRefKeyExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbRefKeyExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbGroupByExpression)">
            <summary>
            <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)"/> for general details.
            We modify both the GroupBy and the Select fields of the SqlSelectStatement.
            GroupBy gets just the keys without aliases,
            and Select gets the keys and the aggregates with aliases.
            
            Whenever there exists at least one aggregate with an argument that is not is not a simple
            <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression"/>  over <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression"/>, 
            we create a nested query in which we alias the arguments to the aggregates. 
            That is due to the following two limitations of Sql Server:
            <list type="number">
            <item>If an expression being aggregated contains an outer reference, then that outer 
            reference must be the only column referenced in the expression </item>
            <item>Sql Server cannot perform an aggregate function on an expression containing 
            an aggregate or a subquery. </item>
            </list>
            
            The default translation, without inner query is: 
            
                SELECT 
                    kexp1 AS key1, kexp2 AS key2,... kexpn AS keyn, 
                    aggf1(aexpr1) AS agg1, .. aggfn(aexprn) AS aggn
                FROM input AS a
                GROUP BY kexp1, kexp2, .. kexpn
            
            When we inject an innner query, the equivalent translation is:
            
                SELECT 
                    key1 AS key1, key2 AS key2, .. keyn AS keys,  
                    aggf1(agg1) AS agg1, aggfn(aggn) AS aggn
                FROM (
                        SELECT 
                            kexp1 AS key1, kexp2 AS key2,... kexpn AS keyn, 
                            aexpr1 AS agg1, .. aexprn AS aggn
                        FROM input AS a
                    ) as a
                GROUP BY key1, key2, keyn
            
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlSelectStatement"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIntersectExpression)">
            <summary>
            <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbUnionAllExpression)"/>
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIsEmptyExpression)">
             <summary>
             Not(IsEmpty) has to be handled specially, so we delegate to
             <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.VisitIsEmptyExpression(System.Data.Common.CommandTrees.DbIsEmptyExpression,System.Boolean)"/>.
            
             </summary>
             <param name="e"></param>
             <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/>.
             <code>[NOT] EXISTS( ... )</code>
             </returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIsNullExpression)">
            <summary>
            Not(IsNull) is handled specially, so we delegate to
            <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.VisitIsNullExpression(System.Data.Common.CommandTrees.DbIsNullExpression,System.Boolean)"/>
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/>
            <code>IS [NOT] NULL</code>
            </returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIsOfExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbIsOfExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbCrossJoinExpression)">
            <summary>
            <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.VisitJoinExpression(System.Collections.Generic.IList{System.Data.Common.CommandTrees.DbExpressionBinding},System.Data.Common.CommandTrees.DbExpressionKind,System.String,System.Data.Common.CommandTrees.DbExpression)"/>
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlSelectStatement"/>.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbJoinExpression)">
            <summary>
            <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.VisitJoinExpression(System.Collections.Generic.IList{System.Data.Common.CommandTrees.DbExpressionBinding},System.Data.Common.CommandTrees.DbExpressionKind,System.String,System.Data.Common.CommandTrees.DbExpression)"/>
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlSelectStatement"/>.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbLikeExpression)">
             <summary>
            
             </summary>
             <param name="e"></param>
             <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbLimitExpression)">
            <summary>
             Translates to TOP expression.
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbNewInstanceExpression)">
             <summary>
             DbNewInstanceExpression is allowed as a child of DbProjectExpression only.
             If anyone else is the parent, we throw.
             We also perform special casing for collections - where we could convert
             them into Unions
            
             <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.VisitNewInstanceExpression(System.Data.Common.CommandTrees.DbNewInstanceExpression)"/> for the actual implementation.
            
             </summary>
             <param name="e"></param>
             <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbNotExpression)">
            <summary>
            The Not expression may cause the translation of its child to change.
            These children are
            <list type="bullet">
            <item><see cref="T:System.Data.Common.CommandTrees.DbNotExpression"/>NOT(Not(x)) becomes x</item>
            <item><see cref="T:System.Data.Common.CommandTrees.DbIsEmptyExpression"/>NOT EXISTS becomes EXISTS</item>
            <item><see cref="T:System.Data.Common.CommandTrees.DbIsNullExpression"/>IS NULL becomes IS NOT NULL</item>
            <item><see cref="T:System.Data.Common.CommandTrees.DbComparisonExpression"/>= becomes&lt;&gt; </item>
            </list>
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbNullExpression)">
            <summary>
            </summary>
            <param name="e"></param>
            <returns><see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbOfTypeExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbOfTypeExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbOrExpression)">
             <summary>
            
             </summary>
             <param name="e"></param>
             <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/></returns>
             <seealso cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbAndExpression)"/>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbParameterReferenceExpression)">
             <summary>
            
             </summary>
             <param name="e"></param>
             <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbProjectExpression)">
            <summary>
            <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)"/> for the general ideas.
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlSelectStatement"/></returns>
            <seealso cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)"/>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbPropertyExpression)">
             <summary>
             This method handles record flattening, which works as follows.
             consider an expression <c>Prop(y, Prop(x, Prop(d, Prop(c, Prop(b, Var(a)))))</c>
             where a,b,c are joins, d is an extent and x and y are fields.
             b has been flattened into a, and has its own SELECT statement.
             c has been flattened into b.
             d has been flattened into c.
            
             We visit the instance, so we reach Var(a) first.  This gives us a (join)symbol.
             Symbol(a).b gives us a join symbol, with a SELECT statement i.e. Symbol(b).
             From this point on , we need to remember Symbol(b) as the source alias,
             and then try to find the column.  So, we use a SymbolPair.
            
             We have reached the end when the symbol no longer points to a join symbol.
             </summary>
             <param name="e"></param>
             <returns>A <see cref="T:FirebirdSql.Data.Entity.JoinSymbol"/> if we have not reached the first
             Join node that has a SELECT statement.
             A <see cref="T:FirebirdSql.Data.Entity.SymbolPair"/> if we have seen the JoinNode, and it has
             a SELECT statement.
             A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/> with {Input}.propertyName otherwise.
             </returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbQuantifierExpression)">
            <summary>
            Any(input, x) => Exists(Filter(input,x))
            All(input, x) => Not Exists(Filter(input, not(x))
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbRefExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbRefExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbRelationshipNavigationExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbRelationshipNavigationExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbSkipExpression)">
            <summary>
            For Sql9 it translates to:
            SELECT Y.x1, Y.x2, ..., Y.xn
            FROM (
                SELECT X.x1, X.x2, ..., X.xn, row_number() OVER (ORDER BY sk1, sk2, ...) AS [row_number] 
                FROM input as X 
                ) as Y
            WHERE Y.[row_number] &gt; count 
            ORDER BY sk1, sk2, ...
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbSortExpression)">
            <summary>
            <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)"/>
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlSelectStatement"/></returns>
            <seealso cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)"/>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbTreatExpression)">
            <summary>
            <see cref="T:System.Data.Common.CommandTrees.DbTreatExpression"/> is illegal at this stage
            </summary>
            <param name="e"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbUnionAllExpression)">
             <summary>
             This code is shared by <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbExceptExpression)"/>
             and <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIntersectExpression)"/>
            
             <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.VisitSetOpExpression(System.Data.Common.CommandTrees.DbExpression,System.Data.Common.CommandTrees.DbExpression,System.String)"/>
             Since the left and right expression may not be Sql select statements,
             we must wrap them up to look like SQL select statements.
             </summary>
             <param name="e"></param>
             <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbVariableReferenceExpression)">
             <summary>
             This method determines whether an extent from an outer scope(free variable)
             is used in the CurrentSelectStatement.
            
             An extent in an outer scope, if its symbol is not in the FromExtents
             of the CurrentSelectStatement.
             </summary>
             <param name="e"></param>
             <returns>A <see cref="T:FirebirdSql.Data.Entity.Symbol"/>.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.VisitAggregate(System.Data.Common.CommandTrees.DbAggregate,System.Object)">
            <summary>
            Aggregates are not visited by the normal visitor walk.
            </summary>
            <param name="aggregate">The aggreate go be translated</param>
            <param name="aggregateArgument">The translated aggregate argument</param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.VisitInputExpression(System.Data.Common.CommandTrees.DbExpression,System.String,System.Data.Metadata.Edm.TypeUsage,FirebirdSql.Data.Entity.Symbol@)">
            <summary>
            This is called by the relational nodes.  It does the following
            <list>
            <item>If the input is not a SqlSelectStatement, it assumes that the input
            is a collection expression, and creates a new SqlSelectStatement </item>
            </list>
            </summary>
            <param name="inputExpression"></param>
            <param name="inputVarName"></param>
            <param name="inputVarType"></param>
            <param name="fromSymbol"></param>
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlSelectStatement"/> and the main fromSymbol
            for this select statement.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.VisitIsEmptyExpression(System.Data.Common.CommandTrees.DbIsEmptyExpression,System.Boolean)">
            <summary>
            <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIsEmptyExpression)"/>
            </summary>
            <param name="e"></param>
            <param name="negate">Was the parent a DbNotExpression?</param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.VisitCollectionConstructor(System.Data.Common.CommandTrees.DbNewInstanceExpression)">
            <summary>
            Translate a NewInstance(Element(X)) expression into
              "select top(1) * from X"
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.VisitIsNullExpression(System.Data.Common.CommandTrees.DbIsNullExpression,System.Boolean)">
            <summary>
            <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIsNullExpression)"/>
            </summary>
            <param name="e"></param>
            <param name="negate">Was the parent a DbNotExpression?</param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.VisitJoinExpression(System.Collections.Generic.IList{System.Data.Common.CommandTrees.DbExpressionBinding},System.Data.Common.CommandTrees.DbExpressionKind,System.String,System.Data.Common.CommandTrees.DbExpression)">
             <summary>
             This handles the processing of join expressions.
             The extents on a left spine are flattened, while joins
             not on the left spine give rise to new nested sub queries.
            
             Joins work differently from the rest of the visiting, in that
             the parent (i.e. the join node) creates the SqlSelectStatement
             for the children to use.
            
             The "parameter" IsInJoinContext indicates whether a child extent should
             add its stuff to the existing SqlSelectStatement, or create a new SqlSelectStatement
             By passing true, we ask the children to add themselves to the parent join,
             by passing false, we ask the children to create new Select statements for
             themselves.
            
             This method is called from <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbApplyExpression)"/> and
             <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbJoinExpression)"/>.
             </summary>
             <param name="inputs"></param>
             <param name="joinKind"></param>
             <param name="joinString"></param>
             <param name="joinCondition"></param>
             <returns> A <see cref="T:FirebirdSql.Data.Entity.SqlSelectStatement"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.ProcessJoinInputResult(FirebirdSql.Data.Entity.ISqlFragment,FirebirdSql.Data.Entity.SqlSelectStatement,System.Data.Common.CommandTrees.DbExpressionBinding,System.Int32)">
             <summary>
             This is called from <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.VisitJoinExpression(System.Collections.Generic.IList{System.Data.Common.CommandTrees.DbExpressionBinding},System.Data.Common.CommandTrees.DbExpressionKind,System.String,System.Data.Common.CommandTrees.DbExpression)"/>.
            
             This is responsible for maintaining the symbol table after visiting
             a child of a join expression.
            
             The child's sql statement may need to be completed.
            
             The child's result could be one of
             <list type="number">
             <item>The same as the parent's - this is treated specially.</item>
             <item>A sql select statement, which may need to be completed</item>
             <item>An extent - just copy it to the from clause</item>
             <item>Anything else (from a collection-valued expression) -
             unnest and copy it.</item>
             </list>
            
             If the input was a Join, we need to create a new join symbol,
             otherwise, we create a normal symbol.
            
             We then call AddFromSymbol to add the AS clause, and update the symbol table.
            
            
            
             If the child's result was the same as the parent's, we have to clean up
             the list of symbols in the FromExtents list, since this contains symbols from
             the children of both the parent and the child.
             The happens when the child visited is a Join, and is the leftmost child of
             the parent.
             </summary>
             <param name="fromExtentFragment"></param>
             <param name="result"></param>
             <param name="input"></param>
             <param name="fromSymbolStart"></param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.VisitNewInstanceExpression(System.Data.Common.CommandTrees.DbNewInstanceExpression)">
            <returns>A <see cref="T:FirebirdSql.Data.Entity.SqlBuilder"/></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.IsSpecialBuiltInFunction(System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Determines whether the given function is a built-in function that requires special handling
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.IsSpecialCanonicalFunction(System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Determines whether the given function is a canonical function that requires special handling
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.HandleFunctionDefault(System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Default handling for functions
            Translates them to FunctionName(arg1, arg2, ..., argn)
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.HandleFunctionDefaultGivenName(System.Data.Common.CommandTrees.DbFunctionExpression,System.String)">
            <summary>
            Default handling for functions with a given name.
            Translates them to functionName(arg1, arg2, ..., argn)
            </summary>
            <param name="e"></param>
            <param name="functionName"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.HandleFunctionArgumentsDefault(System.Data.Common.CommandTrees.DbFunctionExpression,FirebirdSql.Data.Entity.SqlBuilder)">
            <summary>
            Default handling on function arguments
            Appends the list of arguments to the given result
            If the function is niladic it does not append anything,
            otherwise it appends (arg1, arg2, ..., argn)
            </summary>
            <param name="e"></param>
            <param name="result"></param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.HandleSpecialBuiltInFunction(System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Handler for special built in functions
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.HandleSpecialCanonicalFunction(System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Handler for special canonical functions
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.HandleSpecialFunction(System.Collections.Generic.Dictionary{System.String,FirebirdSql.Data.Entity.SqlGenerator.FunctionHandler},System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Dispatches the special function processing to the appropriate handler
            </summary>
            <param name="handlers"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.HandleSpecialFunctionToOperator(System.Data.Common.CommandTrees.DbFunctionExpression,System.Boolean)">
            <summary>
            Handles functions that are translated into TSQL operators.
            The given function should have one or two arguments. 
            Functions with one arguemnt are translated into 
                op arg
            Functions with two arguments are translated into
                arg0 op arg1
            Also, the arguments can be optionaly enclosed in parethesis
            </summary>
            <param name="e"></param>
            <param name="parenthesiseArguments">Whether the arguments should be enclosed in parethesis</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:FirebirdSql.Data.Entity.SqlGenerator.TrimHelper(FirebirdSql.Data.Entity.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression,System.String)" -->
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.HandleCanonicalFunctionExtract(FirebirdSql.Data.Entity.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression,System.String)">
            <summary>
            Handler for canonical funcitons for extracting date parts. 
            For example:
                Year(date) -> EXTRACT(YEAR from date)
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.HandleCanonicalFunctionCreateDateTime(FirebirdSql.Data.Entity.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            CCYY-MM-DD HH:NN:SS.nnnn
            CreateDateTime(year, month, day, hour, minute, second)
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.HandleCanonicalFunctionCreateTime(FirebirdSql.Data.Entity.SqlGenerator,System.Data.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            HH:NN:SS.nnnn
            CreateTime(hour, minute, second)
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.AddColumns(FirebirdSql.Data.Entity.SqlSelectStatement,FirebirdSql.Data.Entity.Symbol,System.Collections.Generic.List{FirebirdSql.Data.Entity.Symbol},System.Collections.Generic.Dictionary{System.String,FirebirdSql.Data.Entity.Symbol},System.String@)">
             <summary>
             <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.AddDefaultColumns(FirebirdSql.Data.Entity.SqlSelectStatement)"/>
             Add the column names from the referenced extent/join to the
             select statement.
            
             If the symbol is a JoinSymbol, we recursively visit all the extents,
             halting at real extents and JoinSymbols that have an associated SqlSelectStatement.
            
             The column names for a real extent can be derived from its type.
             The column names for a Join Select statement can be got from the
             list of columns that was created when the Join's select statement
             was created.
            
             We do the following for each column.
             <list type="number">
             <item>Add the SQL string for each column to the SELECT clause</item>
             <item>Add the column to the list of columns - so that it can
             become part of the "type" of a JoinSymbol</item>
             <item>Check if the column name collides with a previous column added
             to the same select statement.  Flag both the columns for renaming if true.</item>
             <item>Add the column to a name lookup dictionary for collision detection.</item>
             </list>
             </summary>
             <param name="selectStatement">The select statement that started off as SELECT *</param>
             <param name="symbol">The symbol containing the type information for
             the columns to be added.</param>
             <param name="columnList">Columns that have been added to the Select statement.
             This is created in <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.AddDefaultColumns(FirebirdSql.Data.Entity.SqlSelectStatement)"/>.</param>
             <param name="columnDictionary">A dictionary of the columns above.</param>
             <param name="separator">Comma or nothing, depending on whether the SELECT
             clause is empty.</param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.AddDefaultColumns(FirebirdSql.Data.Entity.SqlSelectStatement)">
             <summary>
             Expands Select * to "select the_list_of_columns"
             If the columns are taken from an extent, they are written as
             {original_column_name AS Symbol(original_column)} to allow renaming.
            
             If the columns are taken from a Join, they are written as just
             {original_column_name}, since there cannot be a name collision.
            
             We concatenate the columns from each of the inputs to the select statement.
             Since the inputs may be joins that are flattened, we need to recurse.
             The inputs are inferred from the symbols in FromExtents.
             </summary>
             <param name="selectStatement"></param>
             <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.AddFromSymbol(FirebirdSql.Data.Entity.SqlSelectStatement,System.String,FirebirdSql.Data.Entity.Symbol)">
            <summary>
            <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.AddFromSymbol(FirebirdSql.Data.Entity.SqlSelectStatement,System.String,FirebirdSql.Data.Entity.Symbol,System.Boolean)"/>
            </summary>
            <param name="selectStatement"></param>
            <param name="inputVarName"></param>
            <param name="fromSymbol"></param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.AddFromSymbol(FirebirdSql.Data.Entity.SqlSelectStatement,System.String,FirebirdSql.Data.Entity.Symbol,System.Boolean)">
             <summary>
             This method is called after the input to a relational node is visited.
             <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbProjectExpression)"/> and <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.ProcessJoinInputResult(FirebirdSql.Data.Entity.ISqlFragment,FirebirdSql.Data.Entity.SqlSelectStatement,System.Data.Common.CommandTrees.DbExpressionBinding,System.Int32)"/>
             There are 2 scenarios
             <list type="number">
             <item>The fromSymbol is new i.e. the select statement has just been
             created, or a join extent has been added.</item>
             <item>The fromSymbol is old i.e. we are reusing a select statement.</item>
             </list>
            
             If we are not reusing the select statement, we have to complete the
             FROM clause with the alias
             <code>
             -- if the input was an extent
             FROM = [SchemaName].[TableName]
             -- if the input was a Project
             FROM = (SELECT ... FROM ... WHERE ...)
             </code>
            
             These become
             <code>
             -- if the input was an extent
             FROM = [SchemaName].[TableName] AS alias
             -- if the input was a Project
             FROM = (SELECT ... FROM ... WHERE ...) AS alias
             </code>
             and look like valid FROM clauses.
            
             Finally, we have to add the alias to the global list of aliases used,
             and also to the current symbol table.
             </summary>
             <param name="selectStatement"></param>
             <param name="inputVarName">The alias to be used.</param>
             <param name="fromSymbol"></param>
             <param name="addToSymbolTable"></param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.AddSortKeys(FirebirdSql.Data.Entity.SqlBuilder,System.Collections.Generic.IList{System.Data.Common.CommandTrees.DbSortClause})">
            <summary>
            Translates a list of SortClauses.
            Used in the translation of OrderBy 
            </summary>
            <param name="orderByClause">The SqlBuilder to which the sort keys should be appended</param>
            <param name="sortKeys"></param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.CreateNewSelectStatement(FirebirdSql.Data.Entity.SqlSelectStatement,System.String,System.Data.Metadata.Edm.TypeUsage,FirebirdSql.Data.Entity.Symbol@)">
            <summary>
            <see cref="!:CreateNewSelectStatement(SqlSelectStatement oldStatement, string inputVarName, TypeUsage inputVarType, bool finalizeOldStatement, out Symbol fromSymbol) "/>
            </summary>
            <param name="oldStatement"></param>
            <param name="inputVarName"></param>
            <param name="inputVarType"></param>
            <param name="fromSymbol"></param>
            <returns>A new select statement, with the old one as the from clause.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.CreateNewSelectStatement(FirebirdSql.Data.Entity.SqlSelectStatement,System.String,System.Data.Metadata.Edm.TypeUsage,System.Boolean,FirebirdSql.Data.Entity.Symbol@)">
             <summary>
             This is called after a relational node's input has been visited, and the
             input's sql statement cannot be reused.  <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbProjectExpression)"/>
            
             When the input's sql statement cannot be reused, we create a new sql
             statement, with the old one as the from clause of the new statement.
            
             The old statement must be completed i.e. if it has an empty select list,
             the list of columns must be projected out.
            
             If the old statement being completed has a join symbol as its from extent,
             the new statement must have a clone of the join symbol as its extent.
             We cannot reuse the old symbol, but the new select statement must behave
             as though it is working over the "join" record.
             </summary>
             <param name="oldStatement"></param>
             <param name="inputVarName"></param>
             <param name="inputVarType"></param>
             <param name="finalizeOldStatement"></param>
             <param name="fromSymbol"></param>
             <returns>A new select statement, with the old one as the from clause.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.EscapeSingleQuote(System.String,System.Boolean)">
            <summary>
            Before we embed a string literal in a SQL string, we should
            convert all ' to '', and enclose the whole string in single quotes.
            </summary>
            <param name="s"></param>
            <param name="isUnicode"></param>
            <returns>The escaped sql string.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.GetSqlPrimitiveType(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Returns the sql primitive/native type name. 
            It will include size, precision or scale depending on type information present in the 
            type facets
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.HandleCountExpression(System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            Handles the expression represending DbLimitExpression.Limit and DbSkipExpression.Count.
            If it is a constant expression, it simply does to string thus avoiding casting it to the specific value
            (which would be done if <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbConstantExpression)"/> is called)
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.IsApplyExpression(System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            This is used to determine if a particular expression is an Apply operation.
            This is only the case when the DbExpressionKind is CrossApply or OuterApply.
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.IsJoinExpression(System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            This is used to determine if a particular expression is a Join operation.
            This is true for DbCrossJoinExpression and DbJoinExpression, the
            latter of which may have one of several different ExpressionKinds.
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.IsComplexExpression(System.Data.Common.CommandTrees.DbExpression)">
             <summary>
             This is used to determine if a calling expression needs to place
             round brackets around the translation of the expression e.
            
             Constants, parameters, properties and internal functions as operators do not require brackets,
             everything else does.
             </summary>
             <param name="e"></param>
             <returns>true, if the expression needs brackets </returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.IsCompatible(FirebirdSql.Data.Entity.SqlSelectStatement,System.Data.Common.CommandTrees.DbExpressionKind)">
            <summary>
            Determine if the owner expression can add its unique sql to the input's
            SqlSelectStatement
            </summary>
            <param name="result">The SqlSelectStatement of the input to the relational node.</param>
            <param name="expressionKind">The kind of the expression node(not the input's)</param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.QuoteIdentifier(System.String)">
            <summary>
            We use the normal box quotes for SQL server.  We do not deal with ANSI quotes
            i.e. double quotes.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.VisitExpressionEnsureSqlStatement(System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            Simply calls <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.VisitExpressionEnsureSqlStatement(System.Data.Common.CommandTrees.DbExpression,System.Boolean)"/>
            with addDefaultColumns set to true
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.VisitExpressionEnsureSqlStatement(System.Data.Common.CommandTrees.DbExpression,System.Boolean)">
             <summary>
             This is called from <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.GenerateSql(System.Data.Common.CommandTrees.DbQueryCommandTree)"/> and nodes which require a
             select statement as an argument e.g. <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbIsEmptyExpression)"/>,
             <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbUnionAllExpression)"/>.
            
             SqlGenerator needs its child to have a proper alias if the child is
             just an extent or a join.
            
             The normal relational nodes result in complete valid SQL statements.
             For the rest, we need to treat them as there was a dummy
             <code>
             -- originally {expression}
             -- change that to
             SELECT *
             FROM {expression} as c
             </code>
             
             DbLimitExpression needs to start the statement but not add the default columns
             </summary>
             <param name="e"></param>
             <param name="addDefaultColumns"></param>
             <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.VisitFilterExpression(System.Data.Common.CommandTrees.DbExpressionBinding,System.Data.Common.CommandTrees.DbExpression,System.Boolean)">
             <summary>
             This method is called by <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbFilterExpression)"/> and
             <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbQuantifierExpression)"/>
            
             </summary>
             <param name="input"></param>
             <param name="predicate"></param>
             <param name="negatePredicate">This is passed from <see cref="M:FirebirdSql.Data.Entity.SqlGenerator.Visit(System.Data.Common.CommandTrees.DbQuantifierExpression)"/>
             in the All(...) case.</param>
             <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.WrapNonQueryExtent(FirebirdSql.Data.Entity.SqlSelectStatement,FirebirdSql.Data.Entity.ISqlFragment,System.Data.Common.CommandTrees.DbExpressionKind)">
            <summary>
            If the sql fragment for an input expression is not a SqlSelect statement
            or other acceptable form (e.g. an extent as a SqlBuilder), we need
            to wrap it in a form acceptable in a FROM clause.  These are
            primarily the
            <list type="bullet">
            <item>The set operation expressions - union all, intersect, except</item>
            <item>TVFs, which are conceptually similar to tables</item>
            </list>
            </summary>
            <param name="result"></param>
            <param name="sqlFragment"></param>
            <param name="expressionKind"></param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.IsBuiltInFunction(System.Data.Metadata.Edm.EdmFunction)">
            <summary>
            Is this a builtin function (ie) does it have the builtinAttribute specified?
            </summary>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.WriteFunctionName(FirebirdSql.Data.Entity.SqlBuilder,System.Data.Metadata.Edm.EdmFunction)">
             <summary>
            
             </summary>
             <param name="function"></param>
             <param name="result"></param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.NeedsInnerQuery(System.Collections.Generic.IList{System.Data.Common.CommandTrees.DbAggregate})">
            <summary>
            Helper method for the Group By visitor
            Returns true if at least one of the aggregates in the given list
            has an argument that is not a <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression"/> 
            over <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression"/>
            </summary>
            <param name="aggregates"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlGenerator.IsPropertyOverVarRef(System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            Determines whether the given expression is a <see cref="T:System.Data.Common.CommandTrees.DbPropertyExpression"/> 
            over <see cref="T:System.Data.Common.CommandTrees.DbVariableReferenceExpression"/>
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="P:FirebirdSql.Data.Entity.SqlGenerator.CurrentSelectStatement">
            <summary>
            The top of the stack
            </summary>
        </member>
        <member name="P:FirebirdSql.Data.Entity.SqlGenerator.IsParentAJoin">
            <summary>
            The top of the stack
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Isql.FbBatchExecution">
            <summary>
            Summary description for BatchExecution.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbBatchExecution.#ctor">
            <summary>
            Creates an instance of FbBatchExecution engine.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbBatchExecution.#ctor(FirebirdSql.Data.FirebirdClient.FbConnection)">
            <summary>
            Creates an instance of FbBatchExecution engine with the given
            connection.
            </summary>
            <param name="sqlConnection">A <see cref="T:FirebirdSql.Data.FirebirdClient.FbConnection"/> object.</param>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbBatchExecution.#ctor(FirebirdSql.Data.FirebirdClient.FbConnection,FirebirdSql.Data.Isql.FbScript)">
            <summary>
            Initializes a new instance of the <b>FbBatchExecution</b> class with the given
            <see cref="T:FirebirdSql.Data.FirebirdClient.FbConnection"/> and <see cref="T:FirebirdSql.Data.Isql.FbScript"/> instances.
            </summary>
            <param name="sqlConnection">A <see cref="T:FirebirdSql.Data.FirebirdClient.FbConnection"/> object.</param>
            <param name="isqlScript">A <see cref="T:FirebirdSql.Data.Isql.FbScript"/> object.</param>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbBatchExecution.Execute">
            <summary>
            Starts the ordered execution of the SQL statements that are in <see cref="P:FirebirdSql.Data.Isql.FbBatchExecution.SqlStatements"/> collection.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbBatchExecution.Execute(System.Boolean)">
            <summary>
            Starts the ordered execution of the SQL statements that are in <see cref="P:FirebirdSql.Data.Isql.FbBatchExecution.SqlStatements"/> collection.
            </summary>
            <param name="autoCommit">Specifies if the transaction should be committed after a DDL command execution</param>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbBatchExecution.ConnectToDatabase(System.String)">
            <summary>
            Updates the connection string with the data parsed from the parameter and opens a connection
            to the database.
            </summary>
            <param name="connectDbStatement"></param>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbBatchExecution.CreateDatabase(System.String)">
            <summary>
            Parses the isql statement CREATE DATABASE and creates the database and opens a connection to the recently created database.
            </summary>
            <param name="createDbStatement">the create database statement.</param>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbBatchExecution.SetDatabase(System.String)">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbBatchExecution.ProvideCommand">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbBatchExecution.ProvideConnection">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbBatchExecution.ExecuteCommand(FirebirdSql.Data.FirebirdClient.FbCommand,System.Boolean)">
            <summary>
            Executes a command and optionally commits the transaction.
            </summary>
            <param name="command">Command to execute.</param>
            <param name="autocommit">true to commit the transaction after execution; or false if not.</param>
            <returns>The number of rows affected by the query execution.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbBatchExecution.OnCommandExecuting(FirebirdSql.Data.FirebirdClient.FbCommand)">
            <summary>
            The trigger function for <see cref="E:FirebirdSql.Data.Isql.FbBatchExecution.CommandExecuting"/>	event.
            </summary>
            <param name="sqlCommand">The SQL command that is going for execution.</param>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbBatchExecution.OnCommandExecuted(System.String,FirebirdSql.Data.FirebirdClient.FbDataReader,System.Int32)">
            <summary>
            The trigger function for <see cref="E:FirebirdSql.Data.Isql.FbBatchExecution.CommandExecuted"/> event.
            </summary>
            <param name="commandText">The <see cref="P:FirebirdSql.Data.FirebirdClient.FbCommand.CommandText"/> of the executed SQL command.</param>
            <param name="dataReader">The <see cref="T:FirebirdSql.Data.FirebirdClient.FbDataReader"/> instance with the returned data. If the 
            command executed is not meant to return data (ex: UPDATE, INSERT...) this parameter must be 
            setled to <b>null</b>.</param>
            <param name="rowsAffected">The rows that were affected by the executed SQL command. If the executed 
            command is not meant to return this kind of information (ex: SELECT) this parameter must 
            be setled to <b>-1</b>.</param>
        </member>
        <member name="M:FirebirdSql.Data.Isql.FbBatchExecution.GetStatementType(System.String)">
            <summary>
            Determines the <see cref="T:FirebirdSql.Data.Isql.SqlStatementType"/> of the provided SQL statement.
            </summary>
            <param name="sqlStatement">The string containing the SQL statement.</param>
            <returns>The <see cref="T:FirebirdSql.Data.Isql.SqlStatementType"/> of the <b>sqlStatement</b>.</returns>
            <remarks>If the type of <b>sqlStatement</b> could not be determinated this 
            method will throw an exception.</remarks>
        </member>
        <member name="E:FirebirdSql.Data.Isql.FbBatchExecution.CommandExecuting">
            <summary>
            The event trigged before a SQL statement goes for execution.
            </summary>
        </member>
        <member name="E:FirebirdSql.Data.Isql.FbBatchExecution.CommandExecuted">
            <summary>
            The event trigged after a SQL statement execution.
            </summary>
        </member>
        <member name="P:FirebirdSql.Data.Isql.FbBatchExecution.SqlStatements">
            <summary>
            Represents the list of SQL statements for batch execution.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Entity.MetadataHelpers">
            <summary>
            A set of static helpers for type metadata
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Entity.MetadataHelpers.MaxLengthFacetName">
            <summary>
            Name of the MaxLength Facet
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Entity.MetadataHelpers.UnicodeFacetName">
            <summary>
            Name of the Unicode Facet
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Entity.MetadataHelpers.FixedLengthFacetName">
            <summary>
            Name of the FixedLength Facet
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Entity.MetadataHelpers.PrecisionFacetName">
            <summary>
            Name of the Precision Facet
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Entity.MetadataHelpers.ScaleFacetName">
            <summary>
            Name of the Scale Facet
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Entity.MetadataHelpers.DefaultValueFacetName">
            <summary>
            Name of the DefaultValue Facet
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Entity.MetadataHelpers.NullableFacetName">
            <summary>
            Name of the Nullable Facet
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Entity.MetadataHelpers.StoreGeneratedPatternFacetName">
            <summary>
            Name of StoreGeneratedPattern Facet
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.MetadataHelpers.GetEdmType``1(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Cast the EdmType of the given type usage to the given TEdmType
            </summary>
            <typeparam name="TEdmType"></typeparam>
            <param name="typeUsage"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.MetadataHelpers.GetElementTypeUsage(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Gets the TypeUsage of the elment if the given type is a collection type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.MetadataHelpers.GetProperties(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Retrieves the properties of in the EdmType underlying the input type usage, 
             if that EdmType is a structured type (EntityType, RowType). 
            </summary>
            <param name="typeUsage"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.MetadataHelpers.GetProperties(System.Data.Metadata.Edm.EdmType)">
            <summary>
            Retrieves the properties of the given EdmType, if it is
             a structured type (EntityType, RowType). 
            </summary>
            <param name="edmType"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.MetadataHelpers.IsCollectionType(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Is the given type usage over a collection type
            </summary>
            <param name="typeUsage"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.MetadataHelpers.IsCollectionType(System.Data.Metadata.Edm.EdmType)">
            <summary>
            Is the given type a collection type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.MetadataHelpers.IsPrimitiveType(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Is the given type usage over a primitive type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.MetadataHelpers.IsPrimitiveType(System.Data.Metadata.Edm.EdmType)">
            <summary>
            Is the given type a primitive type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.MetadataHelpers.IsRowType(System.Data.Metadata.Edm.TypeUsage)">
            <summary>
            Is the given type usage over a row type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.MetadataHelpers.IsRowType(System.Data.Metadata.Edm.EdmType)">
            <summary>
            Is the given type a row type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.MetadataHelpers.TryGetPrimitiveTypeKind(System.Data.Metadata.Edm.TypeUsage,System.Data.Metadata.Edm.PrimitiveTypeKind@)">
            <summary>
            Gets the type of the given type usage if it is a primitive type
            </summary>
            <param name="type"></param>
            <param name="typeKind"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.MetadataHelpers.TryGetValueForMetadataProperty``1(System.Data.Metadata.Edm.MetadataItem,System.String)">
            <summary>
            Gets the value for the metadata property with the given name
            </summary>
            <typeparam name="T"></typeparam>
            <param name="item"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.MetadataHelpers.GetFacetValueOrDefault``1(System.Data.Metadata.Edm.TypeUsage,System.String,``0)">
            <summary>
            Get the value specified on the given type usage for the given facet name.
            If the faces does not have a value specifid or that value is null returns
            the default value for that facet.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <param name="facetName"></param>
            <returns></returns>
            <summary>
            Get the value specified on the given type usage for the given facet name.
            If the faces does not have a value specifid or that value is null returns
            the default value for that facet.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <param name="facetName"></param>
            <returns></returns>
        </member>
        <member name="M:FirebirdSql.Data.Entity.MetadataHelpers.TryGetTypeFacetDescriptionByName(System.Data.Metadata.Edm.EdmType,System.String,System.Data.Metadata.Edm.FacetDescription@)">
            <summary>
            Given a facet name and an EdmType, tries to get that facet's description.
            </summary>
            <param name="edmType"></param>
            <param name="facetName"></param>
            <param name="facetDescription"></param>
            <returns></returns>
        </member>
        <member name="T:FirebirdSql.Data.Client.Native.FbClientFactory">
            <summary>
            This class generates a dynamic class that implements the <see cref="T:FirebirdSql.Data.Client.Native.IFbClient"/> interface and
            calls the native methods in a given "fbembed.dll" (though you can name it anything you like).
            </summary>
        </member>
        <member name="F:FirebirdSql.Data.Client.Native.FbClientFactory.cache">
            <summary>
            Because generating the class at runtime is expensive, we cache it here based on the name
            specified.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Client.Native.FbClientFactory.#cctor">
            <summary>
            Static constructor sets up member variables.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Client.Native.FbClientFactory.GetFbClient(System.String)">
            <summary>
            Dynamically generates a class that will load the "fbembed.dll" given in <c>dllName</c>, and that
            also implements <see cref="T:FirebirdSql.Data.Client.Native.IFbClient"/>, which you can use to call the library.
            </summary>
            <param name="dllName">The name of the DLL to load (e.g. "fbembed", "C:\path\to\fbembed.dll", etc)</param>
            <returns>A class that implements <see cref="T:FirebirdSql.Data.Client.Native.IFbClient"/> and calls into the native library you specify.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Client.Native.FbClientFactory.GenerateFbClient(System.String)">
            <summary>
            This method does the "heavy-lifting" of actually generating a dynamic class that implements
            <see cref="T:FirebirdSql.Data.Client.Native.IFbClient"/>, and calls the native library specified to do the actual work.
            </summary>
            <param name="dllName">The name of the libarary to use, as passed into the 
            <see cref="T:System.Runtime.InteropServices.DllImportAttribute"/> that is dynamically generated.</param>
            <returns>An implementation of <see cref="T:FirebirdSql.Data.Client.Native.IFbClient"/>.</returns>
            <remarks>
            <para>Note: To be completly generic, we actually reflect through <see cref="T:FirebirdSql.Data.Client.Native.IFbClient"/>
            to get the methods and parameters to generate.</para>
            </remarks>
        </member>
        <member name="M:FirebirdSql.Data.Client.Native.FbClientFactory.GenerateMethod(System.Reflection.Emit.TypeBuilder,System.Reflection.MethodInfo,System.String)">
            <summary>
            Generates a method on our <see cref="T:System.Reflection.Emit.TypeBuilder"/> for the specified <see cref="T:System.Reflection.MethodInfo"/>
            </summary>
            <param name="tb">The <see cref="T:System.Reflection.Emit.TypeBuilder"/> we're generating our type with.</param>
            <param name="mi">The <see cref="T:System.Reflection.MethodInfo"/> which represents the "template" method.</param>
            <param name="dllName">The path to the DLL that we'll put in the <see cref="T:System.Runtime.InteropServices.DllImportAttribute"/>.</param>
        </member>
        <member name="M:FirebirdSql.Data.Client.Native.FbClientFactory.CreateInstance(System.Reflection.Emit.TypeBuilder)">
            <summary>
            Creates an instance of the type itself and returns it. Cool!!
            </summary>
            <param name="tb">The <see cref="T:System.Reflection.Emit.TypeBuilder"/> that we created our type with.</param>
            <returns>An instance of our type, cast as an <see cref="T:FirebirdSql.Data.Client.Native.IFbClient"/>.</returns>
        </member>
        <member name="M:FirebirdSql.Data.Client.Native.FbClientFactory.CreateTypeBuilder(System.String)">
            <summary>
            Creates the assembly and module into which we'll generate our class, and returns
            a <see cref="T:System.Reflection.Emit.TypeBuilder"/> we can use for building up our type.
            </summary>
            <param name="baseName">The "base name" to use for the name of the assembly and mode.</param>
            <returns>A <see cref="T:System.Reflection.Emit.TypeBuilder"/> which we can use for building our type.</returns>
            <remarks>
            <para>Notice that we actually generate a new assembly for every different <c>dllName</c> that is
            passed into <see cref="M:FirebirdSql.Data.Client.Native.FbClientFactory.GenerateFbClient(System.String)"/>. This might be inefficient, but since we're mostly
            only ever going to have one (or maybe two) different <c>dllName</c>s, it's not a big deal.</para>
            </remarks>
        </member>
        <member name="M:FirebirdSql.Data.Client.Native.FbClientFactory.SanitizeBaseName(System.String)">
            <summary>
            Because the <c>baseName</c> could include things like '\' and '/' - which are not legal
            type names, we need to "sanitize" the name and make it acceptable.
            </summary>
            <param name="baseName">The "base name" which we'll make sure contains only legal
            identfier characters.</param>
            <returns>A new string that is a value type name.</returns>
        </member>
        <member name="T:FirebirdSql.Data.Entity.SymbolPair">
            <summary>
            The SymbolPair exists to solve the record flattening problem.
            <see cref="!:SqlGenerator.Visit(PropertyExpression)"/>
            Consider a property expression D(v, "j3.j2.j1.a.x")
            where v is a VarRef, j1, j2, j3 are joins, a is an extent and x is a columns.
            This has to be translated eventually into {j'}.{x'}
            
            The source field represents the outermost SqlStatement representing a join
            expression (say j2) - this is always a Join symbol.
            
            The column field keeps moving from one join symbol to the next, until it
            stops at a non-join symbol.
            
            This is returned by <see cref="!:SqlGenerator.Visit(PropertyExpression)"/>,
            but never makes it into a SqlBuilder.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Entity.SSDLToFBBase">
            <summary>
            Base class for this transformation
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SSDLToFBBase.Write(System.String)">
            <summary>
            Write text directly into the generated output
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SSDLToFBBase.WriteLine(System.String)">
            <summary>
            Write text directly into the generated output
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SSDLToFBBase.Write(System.String,System.Object[])">
            <summary>
            Write formatted text directly into the generated output
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SSDLToFBBase.WriteLine(System.String,System.Object[])">
            <summary>
            Write formatted text directly into the generated output
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SSDLToFBBase.Error(System.String)">
            <summary>
            Raise an error
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SSDLToFBBase.Warning(System.String)">
            <summary>
            Raise a warning
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SSDLToFBBase.PushIndent(System.String)">
            <summary>
            Increase the indent
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SSDLToFBBase.PopIndent">
            <summary>
            Remove the last indent that was added with PushIndent
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SSDLToFBBase.ClearIndent">
            <summary>
            Remove any indentation
            </summary>
        </member>
        <member name="P:FirebirdSql.Data.Entity.SSDLToFBBase.GenerationEnvironment">
            <summary>
            The string builder that generation-time code is using to assemble generated output
            </summary>
        </member>
        <member name="P:FirebirdSql.Data.Entity.SSDLToFBBase.Errors">
            <summary>
            The error collection for the generation process
            </summary>
        </member>
        <member name="P:FirebirdSql.Data.Entity.SSDLToFBBase.indentLengths">
            <summary>
            A list of the lengths of each indent that was added with PushIndent
            </summary>
        </member>
        <member name="P:FirebirdSql.Data.Entity.SSDLToFBBase.CurrentIndent">
            <summary>
            Gets the current indent we use when adding lines to the output
            </summary>
        </member>
        <member name="P:FirebirdSql.Data.Entity.SSDLToFBBase.Session">
            <summary>
            Current transformation session
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SSDLToFB.GetInput``1(System.String)">
            <summary>
            Retrieve data of type T from CallContext given a string-based identity.
            This is used to pass data from a workflow into the template since the workflow
            utilizes the VS TextTemplatingService which runs the template in a separate AppDomain.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Entity.SSDLToFB.ToStringInstanceHelper">
            <summary>
            Utility class to produce culture-oriented representation of an object as a string.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SSDLToFB.ToStringInstanceHelper.ToStringWithCulture(System.Object)">
            <summary>
            This is called from the compile/run appdomain to convert objects within an expression block to a string
            </summary>
        </member>
        <member name="P:FirebirdSql.Data.Entity.SSDLToFB.ToStringInstanceHelper.FormatProvider">
            <summary>
            Gets or sets format provider to be used by ToStringWithCulture method.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Client.Managed.Version11.SSPIHelper.#ctor">
            <summary>
            Creates SSPIHelper with default "NTLM" security package and no remote principal and gets client credentials
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Client.Managed.Version11.SSPIHelper.#ctor(System.String)">
            <summary>
            Creates SSPIHelper with given security package and no remote principal and gets client credentials
            </summary>
            <param name="securPackage">Name of security package (e.g. NTLM, Kerberos, ...)</param>
        </member>
        <member name="M:FirebirdSql.Data.Client.Managed.Version11.SSPIHelper.#ctor(System.String,System.String)">
            <summary>
            Creates SSPIHelper with given security package and remote principal and gets client credentials
            </summary>
            <param name="securPackage">Name of security package (e.g. NTLM, Kerberos, ...)</param>
            <param name="remotePrincipal">SPN of server (may be necessary for Kerberos</param>
        </member>
        <member name="M:FirebirdSql.Data.Client.Managed.Version11.SSPIHelper.InitializeClientSecurity">
            <summary>
            Creates client security context and returns "client token"
            </summary>
            <returns>Client authentication data to be sent to server</returns>
        </member>
        <member name="M:FirebirdSql.Data.Client.Managed.Version11.SSPIHelper.GetClientSecurity(System.Byte[])">
            <summary>
            Creates client authentication data based on already existing security context and
            authentication data sent by server
            This method must not be called before InitializeClientSecurity
            </summary>
            <param name="serverToken">Authentication data received from server</param>
            <returns>Client authentication data to be sent to server</returns>
        </member>
        <member name="T:FirebirdSql.Data.Isql.CommandExecutedEventArgs">
            <summary>
            Summary description for CommandExecutedEventArgs.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Isql.CommandExecutedEventArgs.#ctor(FirebirdSql.Data.FirebirdClient.FbDataReader,System.String,System.Int32)">
            <summary>
            Creates an instance of CommandExecutedEventArgs class.
            </summary>
            <param name="dataReader"></param>
            <param name="commandText">The CommandText of the <see cref="T:FirebirdSql.Data.FirebirdClient.FbCommand"/> that was executed.</param>
            <param name="rowsAffected"></param>
        </member>
        <member name="M:FirebirdSql.Data.Isql.CommandExecutedEventArgs.ToString">
            <summary>
            Overrided. Returns the SQL statement that was executed.
            </summary>
            <returns>The SQL statement that will be executed.</returns>
        </member>
        <member name="P:FirebirdSql.Data.Isql.CommandExecutedEventArgs.StatementType">
            <summary>
            Returns the <see cref="T:FirebirdSql.Data.Isql.SqlStatementType"/> of the current <see cref="P:FirebirdSql.Data.Isql.CommandExecutedEventArgs.CommandText"/>.
            </summary>
        </member>
        <member name="P:FirebirdSql.Data.Isql.CommandExecutedEventArgs.CommandText">
            <summary>
            Returns the SQL statement that was executed.
            </summary>
        </member>
        <member name="P:FirebirdSql.Data.Isql.CommandExecutedEventArgs.DataReader">
            <summary>
            Returns a <see cref="T:FirebirdSql.Data.FirebirdClient.FbDataReader"/> instance case the executed SQL command returns data. If
            the executed SQL command does not returns data, (for instance: the case of an UPDATE statement), 
            the <b>DataReader</b> is setled to <b>null</b>.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Entity.SqlBuilder">
            <summary>
            This class is like StringBuilder.  While traversing the tree for the first time, 
            we do not know all the strings that need to be appended e.g. things that need to be
            renamed, nested select statements etc.  So, we use a builder that can collect
            all kinds of sql fragments.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlBuilder.Append(System.Object)">
            <summary>
            Add an object to the list - we do not verify that it is a proper sql fragment
            since this is an internal method.
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlBuilder.AppendLine">
            <summary>
            This is to pretty print the SQL.  The writer <see cref="M:FirebirdSql.Data.Entity.SqlWriter.Write(System.String)"/>
            needs to know about new lines so that it can add the right amount of 
            indentation at the beginning of lines.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.SqlBuilder.WriteSql(FirebirdSql.Data.Entity.SqlWriter,FirebirdSql.Data.Entity.SqlGenerator)">
            <summary>
            We delegate the writing of the fragment to the appropriate type.
            </summary>
            <param name="writer"></param>
            <param name="sqlGenerator"></param>
        </member>
        <member name="P:FirebirdSql.Data.Entity.SqlBuilder.IsEmpty">
            <summary>
            Whether the builder is empty.  This is used by the <see cref="!:SqlGenerator.Visit(ProjectExpression)"/>
            to determine whether a sql statement can be reused.
            </summary>
        </member>
        <member name="T:FirebirdSql.Data.Entity.DmlSqlGenerator">
            <summary>
            Class generating SQL for a DML command tree.
            </summary>
        </member>
        <member name="M:FirebirdSql.Data.Entity.DmlSqlGenerator.GenerateReturningSql(System.Text.StringBuilder,System.Data.Common.CommandTrees.DbModificationCommandTree,FirebirdSql.Data.Entity.ExpressionTranslator,System.Data.Common.CommandTrees.DbExpression)">
            <summary>
            Generates SQL fragment returning server-generated values.
            Requires: translator knows about member values so that we can figure out
            how to construct the key predicate.
            <code>
            Sample SQL:
                
                select IdentityValue
                from dbo.MyTable
                where @@ROWCOUNT > 0 and IdentityValue = scope_identity()
            
            or
            
                select TimestamptValue
                from dbo.MyTable
                where @@ROWCOUNT > 0 and Id = 1
            
            Note that we filter on rowcount to ensure no rows are returned if no rows were modified.
            </code>
            </summary>
            <param name="commandText">Builder containing command text</param>
            <param name="tree">Modification command tree</param>
            <param name="translator">Translator used to produce DML SQL statement
            for the tree</param>
            <param name="returning">Returning expression. If null, the method returns
            immediately without producing a SELECT statement.</param>
        </member>
    </members>
</doc>
