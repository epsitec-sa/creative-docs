using Epsitec.Common.Widgets;
using Epsitec.Common.Support;
using Epsitec.Common.Pictogram.Widgets;
using System.Xml.Serialization;

namespace Epsitec.Common.Pictogram.Data
{
	public enum PropertyType
	{
		None,				// aucune
		LineColor,			// couleur du trait
		LineMode,			// mode du trait
		FillGradient,		// dégradé de remplissage
		Shadow,				// ombre sous l'objet
		PolyClose,			// mode de fermeture des polygones
		Corner,				// coins des rectangles
		Regular,			// définitions du polygone régulier
		TextString,			// texte
		TextFontName,		// police
		TextFontOptical,	// police
	}

	/// <summary>
	/// La classe Property représente une propriété d'un objet graphique.
	/// </summary>
	public abstract class AbstractProperty
	{
		public AbstractProperty()
		{
		}

		// Crée une nouvelle propriété.
		static public AbstractProperty NewProperty(PropertyType type)
		{
			AbstractProperty property = null;
			switch ( type )
			{
				case PropertyType.LineColor:        property = new PropertyColor();     break;
				case PropertyType.LineMode:         property = new PropertyLine();      break;
				case PropertyType.FillGradient:     property = new PropertyGradient();  break;
				case PropertyType.Shadow:           property = new PropertyShadow();    break;
				case PropertyType.PolyClose:        property = new PropertyBool();      break;
				case PropertyType.Corner:           property = new PropertyCorner();    break;
				case PropertyType.Regular:          property = new PropertyRegular();   break;
				case PropertyType.TextString:       property = new PropertyString();    break;
				case PropertyType.TextFontName:     property = new PropertyCombo();     break;
				case PropertyType.TextFontOptical:  property = new PropertyCombo();     break;
			}
			if ( property == null )  return null;
			property.Type = type;
			return property;
		}

		// Type de la propriété.
		[XmlAttribute]
		public PropertyType Type
		{
			get { return this.type; }
			set { this.type = value; }
		}

		// Nom de la propriété.
		[XmlIgnore]
		public string Text
		{
			get { return this.text; }
			set { this.text = value; }
		}

		// Couleur de fond du panneau associé.
		[XmlIgnore]
		public double BackgroundIntensity
		{
			get { return this.backgroundIntensity; }
			set { this.backgroundIntensity = value; }
		}

		// Mode de déploiement du panneau associé.
		[XmlIgnore]
		public bool ExtendedSize
		{
			get { return this.extendedSize; }
			set { this.extendedSize = value; }
		}

		// Représentation de plusieurs propriétés contradictoires.
		[XmlIgnore]
		public bool Multi
		{
			get { return this.multi; }
			set { this.multi = value; }
		}

		// Indique s'il faut éditer les propriétés.
		[XmlIgnore]
		public bool EditProperties
		{
			get { return this.editProperties; }
			set { this.editProperties = value; }
		}

		// Indique si un changement de cette propriété modifie la bbox de l'objet.
		[XmlIgnore]
		public virtual bool AlterBoundingBox
		{
			get { return false; }
		}

		// Effectue une copie de la propriété.
		public virtual void CopyTo(AbstractProperty property)
		{
			this.CopyInfoTo(property);
			property.editProperties = this.editProperties;
		}

		// Effectue une copie des informations de base de la propriété.
		public virtual void CopyInfoTo(AbstractProperty property)
		{
			property.type                = this.type;
			property.text                = this.text;
			property.backgroundIntensity = this.backgroundIntensity;
			property.extendedSize        = this.extendedSize;
			property.multi               = this.multi;
		}

		// Compare deux propriétés.
		public virtual bool Compare(AbstractProperty property)
		{
			if ( property.type != this.type )  return false;
			return true;
		}

		// Cherche une propriété de même type dans une liste.
		public AbstractProperty Search(System.Collections.ArrayList list)
		{
			foreach ( AbstractProperty property in list )
			{
				if ( property.Type == this.type )  return property;
			}
			return null;
		}

		// Crée le panneau permettant d'éditer la propriété.
		public virtual AbstractPanel CreatePanel()
		{
			return null;
		}


		// Nombre de poignées.
		public virtual int TotalHandle
		{
			get { return this.handles.Count; }
		}

		// Donne une poignée de la propriété.
		public virtual Handle Handle(int rank, Drawing.Rectangle bbox)
		{
			return null;
		}

		// Début du déplacement d'une poignée de la propriété.
		public virtual void MoveHandleStarting(int rank, Drawing.Point pos, Drawing.Rectangle bbox, IconContext iconContext)
		{
			iconContext.ConstrainFixStarting(pos);
		}

		// Déplace une poignée de la propriété.
		public virtual void MoveHandleProcess(int rank, Drawing.Point pos, Drawing.Rectangle bbox, IconContext iconContext)
		{
		}

		// Indique si les poignées sont visibles.
		public virtual bool IsHandleVisible()
		{
			return false;
		}

		// Dessine les traits de construction avant les poignées.
		public virtual void DrawEdit(Drawing.Graphics graphics, IconContext iconContext, Drawing.Rectangle bbox)
		{
		}


		// Génère un événement pour dire que la propriété a changé.
		// En fait, ce sont les objets qui vont écouter cet événement, pour
		// éventuellement modifier les poignées qui reflètent les propriétés.
		protected virtual void OnChanged()
		{
			if ( this.Changed != null )  // qq'un écoute ?
			{
				this.Changed(this);
			}
		}

		public event EventHandler Changed;


		protected string						text;
		protected double						backgroundIntensity;
		protected bool							extendedSize = false;
		protected bool							multi = false;
		protected bool							editProperties = false;

		protected PropertyType					type;
		protected System.Collections.ArrayList	handles = new System.Collections.ArrayList();
	}
}
