
Ce qu'il reste à faire dans "Database"
--------------------------------------

-	La classe DbInfrastructure n'est pas terminée, en particulier:

	o	La méthode RegisterCrossTableReferences n'est pas implémentée.
	
	o	La méthode CreateLocalisedColumns n'est pas implémentée.
	
	o	Il faudra aussi compléter LoadDbTable pour que les DbColumn créées
		soient initialisées correctement par rapport à leur propriété
		TargetTableName.
	
	o	Les instances de DbTable créées par CreateDatabase ne sont pas
		tout à fait correctes, car leur propriété DbColumn.TargetTableName
		n'est pas initialisée.

-	Tester DbRichCommand.CreateEmptyDataSet.

-	Soit créer une classe DbSelect pour réaliser ce que SqlSelect fait,
	en se basant sur des données et des descriptions "abstraites" et
	indépendants de SQL, ou alors ajouter un ensemble de méthodes dans
	DbInfrastructure pour créer un objet SqlSelect ad hoc.
	
	Voir par exemple DbRichCommandTest pour un exemple de ce qui est
	fait actuellement manuellement, mais qui pourrait être déplacé dans
	la logique de DbInfrastructure.



-----------------------------------------------------------------
META DONNEES DANS LA BASE
-----------------------------------------------------------------

Pour résumer les choses : DbInfrastructure est responsable de la
gestion des méta-données stockées dans la base; celles-ci sont re-
présentées par DbTable/DbColumn/DbType/...

Pour pouvoir gérer ces méta-données, il y a un certain nombre de
tables qui sont créées dans la base. Les tables 'système' de Crésus
sont toutes préfixées par "CR_" et celles de l'utilisateur par "U_".
Il y a aussi un champ DbElementCat dans DbTable/DbColumn qui permet
de savoir de quoi il retourne.

Les tables suivantes sont définies :

    CR_TABLE_DEF        (nom DbTable.TagTableDef)
    CR_COLUMN_DEF       (nom DbTable.TagColumnDef)
    CR_TYPE_DEF         (nom DbTable.TagTypeDef)
    CR_ENUM_VAL_DEF     (nom DbTable.TagEnumValDef)
    CR_RELATION_DEF     (nom DbTable.TagRelationDef)

- CR_TABLE_DEF définit les informations de base d'une table :

    o Clef.
    o Nom de haut niveau (CR_NAME).
    o Titre (CR_CAPTION) et description (CR_DESCRIPTION).
    o Info supplémentaire XML (CR_INFO).
    o ID (clef) de la prochaine ligne dans la table (CR_NEXT_ID).

- CR_COLUMN_DEF définit les descriptions des colonnes :

    o Clef.
    o Nom de haut niveau, titre, description, info XML.
    o Référence à l'ID de la table (CREF_TABLE).
    o Référence au type (CREF_TYPE).

- CR_TYPE_DEF définit un type de donnée :

    o Clef.
    o Nom de haut niveau, titre, description, info XML.

- CR_ENUM_VAL_DEF définit une valeur d'une énumération :

    o Clef.
    o Nom de haut niveau, titre, description, info XML.
    o Référence au type (CREF_TYPE) qui utilise cette valeur.

- CR_RELATION_DEF définit une relation entre la colonne d'une table
  source et une table cible :

    o Clef.
    o Référence à la colonne source (CREF_COLUMN).
    o Référence à la table source (CREF_SOURCE) qui est en
      soi superflue, puisqu'on peut la défirver de CREF_COLUMN,
      mais ça permet de simplifier les choses).
    o Référence à la table cible (CREF_TARGET).

La clef est soit une clef simple (CR_ID), soit une clef avec
numéro de version (CR_ID+CR_REV). Dans ce dernier cas, CR_STAT
est ajouté, pour indiquer le statut de la ligne. Pour le moment,
les statuts suivants sont supportés :

    o CR_REV=0, CR_STAT=n, où 'n' est équivalent à MAX(CR_REV)
      pour ce CR_ID, permet de déduire simplement le prochain
      CR_REV sans devoir faire un SELECT avec aggrégat MAX().

    o CR_REV=n, CR_STAT=n, ligne valide, en vie.

    o CR_REV=n, CR_STAT=-1, ligne "effacée". C'est utilisé par
      CR_TABLE_DEF pour indiquer qu'une table a été effacée.

-----------------------------------------------------------------
LOCALISATION DE L'INFORMATION
-----------------------------------------------------------------

Il existe des colonnes CR_CAPTION_xx, CR_DESCRIPTION_xx, etc. où
xx est le nom (2 lettres) de la langue ("fr", "de", "en", "it").

DbInfrastructure.localisations contient une table de tous ces
suffixes supportés par une base donnée. Les méthodes suivantes
peuvent être utilisées pour simplifier le travail avec des colonnes
localisées :

- DefineLocalisedAttributes, extrait d'une ligne d'une DataTable
  les infos de la colonne localisée et définit les valeurs dans
  la collection DbAttributes de DbColumn/DbTable.

- AddLocalisedColumns, ajoute les noms des colonnes à extraire
  pour une requête SELECT qui contient des colonnes localisées.

Une colonne localisée possède un champ DbColumnLocalisation qui
indique si celle-ci n'est pas localisable (None), est localisable
et correspond à la valeur par défaut (sans suffixe; Default) ou
est localisable et localisée (avec suffixe; Localised).
