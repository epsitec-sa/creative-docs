//	Copyright © 2010, EPSITEC SA, CH-1400 Yverdon-les-Bains, Switzerland
//	Author: Marc BETTEX, Maintainer: Marc BETTEX

using Epsitec.Common.Support.Extensions;

using Epsitec.Cresus.Database;

using System.Collections.Generic;
using System.Linq;


namespace Epsitec.Cresus.DataLayer.Infrastructure
{
	/// <summary>
	/// The <c>UidGenerator</c> class allows the generation of unique ids. Each <c>UidGenerator</c>
	/// contains one or more slots which are each defined by a minimum and a maximum value. An
	/// <c>UidGenerator</c> can thus be used to generate unique ids in those slots.
	/// </summary>
	public sealed class UidGenerator
	{
		/// <summary>
		/// Creates a new instance of <c>UidGenerator</c>.
		/// </summary>
		/// <param name="dbInfrastructure">The <see cref="DbInfrastructure"/> used to communicate with the database.</param>
		/// <param name="name">The name of this instance.</param>
		/// <param name="slots">The sequence of minimum and maximum values defining the slots of this instance.</param>
		private UidGenerator(DbInfrastructure dbInfrastructure, string name, IEnumerable<System.Tuple<long, long>> slots)
		{
			this.dbInfrastructure = dbInfrastructure;

			this.slotMinValues = new List<long> ();
			this.slotMaxValues = new List<long> ();

			foreach (var slot in slots)
			{
				this.slotMinValues.Add (slot.Item1);
				this.slotMaxValues.Add (slot.Item2);
			}

			this.Name = name;	
		}


		/// <summary>
		/// The name of this instance.
		/// </summary>
		public string Name
		{
			get;
			private set;
		}


		/// <summary>
		/// The sequence of minimum and maximum values defining the slots of this instance.
		/// </summary>
		public IEnumerable<System.Tuple<long, long>> Slots
		{
			get
			{
				for (int slot = 0; slot < this.slotMinValues.Count; slot++)
				{
					long min = this.slotMinValues[slot];
					long max = this.slotMaxValues[slot];

					yield return System.Tuple.Create (min, max);
				}
			}
		}


		/// <summary>
		/// The low level <see cref="UidManager"/> used to manage the values of the counters.
		/// </summary>
		private DbUidManager UidManager
		{
			get
			{
				return this.dbInfrastructure.UidManager;
			}
		}


		/// <summary>
		/// Gets the next unique id generated by this instance.
		/// </summary>
		/// <returns>The next unique id.</returns>
		/// <exception cref="System.Exception">If a new unique id cannot be generated.</exception>
		public long GetNextUid()
		{
			using (DbTransaction transaction = UidGenerator.CreateWriteTransaction (dbInfrastructure))
			{
				long? uid = this.InternalGetNextUidInSlots (0);

				transaction.Commit ();

				if (!uid.HasValue)
				{
					throw new System.Exception ("Could not create new unique id.");
				}

				return uid.Value;
			}
		}


		/// <summary>
		/// Gets the next unique id generated by this instance in a given slot.
		/// </summary>
		/// <param name="slotIndex">The index of the slot to use.</param>
		/// <returns>The next unique id of the given slot.</returns>
		/// <exception cref="System.ArgumentException">If <paramref name="slotIndex"/> is lower than zero.</exception>
		/// <exception cref="System.ArgumentException">If <paramref name="slotIndex"/> is greater or equal to the number of slots of this instance.</exception>
		/// <exception cref="System.Exception">If a new unique id cannot be generated in the given slot.</exception>
		public long GetNextUidInSlot(int slotIndex)
		{
			slotIndex.ThrowIf (s => s < 0, "slotIndex cannot be lower than zero.");
			slotIndex.ThrowIf (s => s >= this.slotMinValues.Count, "slotIndex cannot be greater or equal to the number of slots.");

			using (DbTransaction transaction = UidGenerator.CreateWriteTransaction (dbInfrastructure))
			{
				long? uid = this.InternalGetNextUidInSlot (slotIndex);

				transaction.Commit ();

				if (!uid.HasValue)
				{
					throw new System.Exception ("Could not create new unique id.");
				}

				return uid.Value;
			}
		}


		/// <summary>
		/// Gets the next unique id in any slot, starting from the slot given by
		/// <paramref name="startSlotIndex"/>
		/// </summary>
		/// <param name="startSlotIndex">The index of the first slot in which to try to generate the next unique id.</param>
		/// <returns>The next unique id.</returns>
		private long? InternalGetNextUidInSlots(int startSlotIndex)
		{
			long? uid = null;

			for (int slotIndex = startSlotIndex; slotIndex < this.slotMinValues.Count && !uid.HasValue; slotIndex++)
			{
				uid = this.InternalGetNextUidInSlot (slotIndex);
			}

			return uid;
		}

		/// <summary>
		/// Gets the next unique id in the given slot.
		/// </summary>
		/// <param name="slotIndex">The index of the slot in which to try to generate the next unique id.</param>
		/// <returns>The next unique id.</returns>
		private long? InternalGetNextUidInSlot(int slotIndex)
		{
			long max = this.slotMaxValues[slotIndex];
			long next = this.UidManager.GetUidCounterNext (this.Name, slotIndex);

			bool isNextValidUid = (next <= max);

			if (isNextValidUid)
			{
				this.UidManager.SetUidCounterNext (this.Name, slotIndex, next + 1);
			}

			return isNextValidUid ? (long?) next : null;
		}


		/// <summary>
		/// Creates a new generator for unique ids in the database.
		/// </summary>
		/// <param name="dbInfrastructure">The <see cref="DbInfrastructure"/> used to communicate with the database.</param>
		/// <param name="name">The name of the generator.</param>
		/// <param name="slots">The definition of the slots of the generator.</param>
		/// <exception cref="System.ArgumentNullException">If <paramref name="dbInfrastructure"/> is <c>null</c>.</exception>
		/// <exception cref="System.ArgumentException">If <paramref name="name"/> is <c>null</c> or empty.</exception>
		/// <exception cref="System.ArgumentNullException">If <paramref name="slots"/> is <c>null</c>.</exception>
		/// <exception cref="System.ArgumentException">If <paramref name="slots"/> is empty.</exception>
		/// <exception cref="System.ArgumentException">If <paramref name="slots"/> contains negative elements.</exception>
		/// <exception cref="System.ArgumentException">If <paramref name="slots"/> contains slots with inconsistent bounds.</exception>
		/// <exception cref="System.ArgumentException">If <paramref name="slots"/> contains overlapping slots.</exception>
		internal static void CreateUidGenerator(DbInfrastructure dbInfrastructure, string name, IEnumerable<System.Tuple<long, long>> slots)
		{
			List<System.Tuple<long, long>> slotsAsList = slots.OrderBy (s => s.Item1).ToList ();

			dbInfrastructure.ThrowIfNull ("dbInfrastructure");
			name.ThrowIfNullOrEmpty ("name");
			slots.ThrowIfNull ("slots");

			if (!slotsAsList.Any ())
			{
				throw new System.ArgumentException ("No slots defined.");
			}

			if (slotsAsList.Any (s => s.Item1 < 0 || s.Item2 < 0))
			{
				throw new System.ArgumentException ("Min and max values cannot be lower than zero.");
			}

			if (slotsAsList.Any (s => s.Item1 > s.Item2))
			{
				throw new System.ArgumentException ("A min value cannot be greater than a max value.");
			}

			for (int i = 0; i < slotsAsList.Count - 1; i++)
			{
				if (slotsAsList[i].Item2 >= slotsAsList[i + 1].Item1)
				{
					throw new System.ArgumentException ("Slots cannot overlap each others.");
				}
			}

			using (DbTransaction transaction = UidGenerator.CreateWriteTransaction (dbInfrastructure))
			{
				if (dbInfrastructure.UidManager.ExistsUidCounter (name, 0))
				{
					throw new System.InvalidOperationException ("UidGenerator " + name + " already exists.");
				}

				for (int i = 0; i < slotsAsList.Count; i++)
				{
					dbInfrastructure.UidManager.CreateUidCounter (name, i, slotsAsList[i].Item1, slotsAsList[i].Item2);
				}

				transaction.Commit ();
			}
		}

		/// <summary>
		/// Deletes a generator for unique ids from the database.
		/// </summary>
		/// <param name="dbInfrastructure">The <see cref="DbInfrastructure"/> used to communicate with the database.</param>
		/// <param name="name">The name of the generator.</param>
		/// <exception cref="System.ArgumentNullException">If <paramref name="dbInfrastructure"/> is <c>null</c>.</exception>
		/// <exception cref="System.ArgumentException">If <paramref name="name"/> is <c>null</c> or empty.</exception>
		internal static void DeleteUidGenerator(DbInfrastructure dbInfrastructure, string name)
		{
			dbInfrastructure.ThrowIfNull ("dbInfrastructure");
			name.ThrowIfNullOrEmpty ("name");

			using (DbTransaction transaction = UidGenerator.CreateWriteTransaction (dbInfrastructure))
			{
				foreach (int slot in UidGenerator.GetSlots (dbInfrastructure, name))
				{
					dbInfrastructure.UidManager.DeleteUidCounter (name, slot);
				}

				transaction.Commit ();
			}
		}

		/// <summary>
		/// Tells whether a generator for unique ids exists in the database.
		/// </summary>
		/// <param name="dbInfrastructure">The <see cref="DbInfrastructure"/> used to communicate with the database.</param>
		/// <param name="name">The name of the generator.</param>
		/// <returns><c>true</c> if a generator with <paramref name="name"/> exists in the database, <c>false</c> if there aren't.</returns>
		/// <exception cref="System.ArgumentNullException">If <paramref name="dbInfrastructure"/> is <c>null</c>.</exception>
		/// <exception cref="System.ArgumentException">If <paramref name="name"/> is <c>null</c> or empty.</exception>
		internal static bool UidGeneratorExists(DbInfrastructure dbInfrastructure, string name)
		{
			dbInfrastructure.ThrowIfNull ("dbInfrastructure");
			name.ThrowIfNullOrEmpty ("name");

			using (DbTransaction transaction = UidGenerator.CreateReadTransaction (dbInfrastructure))
			{
				bool exists = dbInfrastructure.UidManager.ExistsUidCounter (name, 0);

				transaction.Commit ();

				return exists;
			}
		}


		/// <summary>
		/// Gets the <see cref="UidGenerator"/> object used to manipulate a generator of unique ids
		/// in the database.
		/// </summary>
		/// <param name="dbInfrastructure">The <see cref="DbInfrastructure"/> used to communicate with the database.</param>
		/// <param name="name">The name of the generator.</param>
		/// <returns>The <see cref="UidGenerator"/> object.</returns>
		/// <exception cref="System.ArgumentNullException">If <paramref name="dbInfrastructure"/> is <c>null</c>.</exception>
		/// <exception cref="System.ArgumentException">If <paramref name="name"/> is <c>null</c> or empty.</exception>
		/// <exception cref="System.Exception">If the requested <see cref="UidGenerator"/> does not exists.</exception>
		internal static UidGenerator GetUidGenerator(DbInfrastructure dbInfrastructure, string name)
		{
			dbInfrastructure.ThrowIfNull ("dbInfrastructure");
			name.ThrowIfNullOrEmpty ("name");

			using (DbTransaction transaction = UidGenerator.CreateReadTransaction (dbInfrastructure))
			{
				var slots = new List<System.Tuple<long, long>>
				(
					from slot in UidGenerator.GetSlots (dbInfrastructure, name)
					let minValue = dbInfrastructure.UidManager.GetUidCounterMin (name, slot)
					let maxValue = dbInfrastructure.UidManager.GetUidCounterMax (name, slot)
					select System.Tuple.Create (minValue, maxValue)
				);

				transaction.Commit ();

				if (!slots.Any ())
				{
					throw new System.ArgumentException ("Uid generator does not exists.");
				}

				return new UidGenerator (dbInfrastructure, name, slots);
			}
		}


		/// <summary>
		/// Gets the indexes of the slots as stored in the database for a given uid counter.
		/// </summary>
		/// <param name="dbInfrastructure">The <see cref="DbInfrastructure"/> used to communicate with the database.</param>
		/// <param name="name">The name of the counter to use.</param>
		/// <returns>The sequence of slot indexes.</returns>
		private static IEnumerable<int> GetSlots(DbInfrastructure dbInfrastructure, string name)
		{
			return from slotIndex in dbInfrastructure.UidManager.GetUidCounterSlots (name)
				   orderby slotIndex
				   select slotIndex;
		}

		/// <summary>
		/// Creates the <see cref="DbTransaction"/> object that must be used when reading data from
		/// the database.
		/// </summary>
		/// <param name="dbInfrastructure">The <see cref="DbInfrastructure"/> used to communicate with the database.</param>
		/// <returns>The <see cref="DbTransaction"/> that must be used.</returns>
		private static DbTransaction CreateReadTransaction(DbInfrastructure dbInfrastructure)
		{
			return dbInfrastructure.BeginTransaction (DbTransactionMode.ReadOnly);
		}

		/// <summary>
		/// Creates the <see cref="DbTransaction"/> object that must be used when writing data to
		/// the database.
		/// </summary>
		/// <param name="dbInfrastructure">The <see cref="DbInfrastructure"/> used to communicate with the database.</param>
		/// <returns>The <see cref="DbTransaction"/> that must be used.</returns>
		private static DbTransaction CreateWriteTransaction(DbInfrastructure dbInfrastructure)
		{
			List<DbTable> tablesToLock = new List<DbTable> ()
			{
				dbInfrastructure.ResolveDbTable (Tags.TableUid),
			};

			return dbInfrastructure.BeginTransaction (DbTransactionMode.ReadWrite, tablesToLock);
		}


		/// <summary>
		/// The <see cref="DbInfrastructure"/> used to communicate with the database.
		/// </summary>
		private readonly DbInfrastructure dbInfrastructure;

		/// <summary>
		/// The sequence of minimum values of the slots.
		/// </summary>
		private readonly List<long> slotMinValues;

		/// <summary>
		/// The sequence of maximum values of the slots.
		/// </summary>
		private readonly List<long> slotMaxValues;
	}
}
