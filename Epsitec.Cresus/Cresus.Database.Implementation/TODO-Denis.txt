
PROBLEMES
---------

Certaines commandes FirebirdSqlBuilder ne peuvent pas être représentées avec
un objet FbCommand unique (par exemple InsertTable qui génère deux commandes
SQL séparées).

Pour l'instant FbCommand ne supporte qu'une commande.
Question posée le 6/10/2003 à firebird-net-provider@lists.sourceforge.net
Premier élément de réponse; il faut faire :

	System.Data.IDataReader reader = command.ExecuteReader ();
	while (reader.NextResult ()) { }
	
pour forcer l'exécution de toutes les commandes. Par contre, le reader est
dans un état bizarre qui fait que l'on ne peut pas faire de Read() dessus.
C'est franchement gênant.


A FAIRE
-------

-	Tester la fonctionalité actuelle du FirebirdSqlBuilder, en passant par
	l'interface ISqlBuilder :

	-	InsertTable (OK, cf ISqlBuilderTest.CheckInsertTable)
	-	RemoveTable (OK, cf ISqlBuilderTest.CheckRemoveTable)
	-	InsertTableColumns (OK, cf ISqlBuilderTest.CheckInsertTableColumns)
	-	RemoveTableColumns (OK, cf ISqlBuilderTest.CheckRemoveTableColumns)
	-	InsertData (OK, cf ISqlBuilderTest.CheckInsertData)

-	Vérifier que FbTypeConverterTest teste bien correctement l'interface
	IRawTypeConverter. (OK amha)

-	Compléter les méthodes de création de SqlField, ainsi que la méthode
	de validation.

-	Ecrire la classe de test SqlFieldTest.

-	Ajouter les méthodes manquantes dans SqlSelect. Il faudra ajouter des
	méthodes permettant de spécifier les conditions, etc.
	
	Notes:
	
	-	Add permet actuellement de chaîner des requêtes SELECT pour
		créer des 'SETS'. Ce genre de fonctionalité n'est pas du tout une
		priorité actuellement.
	
	-	Tables spécifie les noms des tables qui doivent être utilisées,
		avec leur nom d'alias (attention: il faut faire en sorte que ces
		noms d'alias soient toujours présents, si besoin créés automatique-
		ment).
	
	-	Fields spécifie quels champs doivent être retournés par le SELECT
		(c'est le nom des colonnes, des aggrégats, constantes ou "*").
	
	-	Conditions spécifie les conditions du SELECT. Ces conditions sont
		construites à partir de SqlField contenant une SqlFunction qui à
		son tour contient des instances de SqlField.
		
		Il est vital que les noms de ces champs soient pleinement qualifiés
		(ALIAS_TABLE.NOM_CHAMP) s'ils font référence à des colonnes de
		tables. Voir SqlFieldType.QualifiedName et DbSqlStandard.Qualif...
	
	Les méthodes d'ajout devraient permettre de :
	
	-	Spécifier quels noms de tables utiliser, avec évtl. leur alias.
	
	-	Spécifier quelles colonnes extraire (une méthode d'ajout par type
		de colonne supporté: nom de colonne, cas spécial "*" codé par
		SqlFieldType.All, constantes SqlFieldType.Constant, aggrégats
		SqlFieldType.Aggregate+SqlAggregate, évtl. fonctions).
	
	-	Spécifier les conditions (ce sont là uniquement des fonctions).

-	Ecrire les tests pour les classes SqlFunction et SqlSelect.

-	Compléter DbSqlStandard et DbSqlStandardTest. En particulier les
	méthodes SplitQualifiedName et ValidateQualifiedName.

-	Terminer DbNumDef.

-	Compléter les tests de DbTable (si besoin).

-	Finir FirebirdSqlBuilder (pour SELECT, INSERT, REMOVE, UPDATE en
	particulier), puis tester.
