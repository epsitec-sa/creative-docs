using System.Collections.Generic;
using System.Runtime.Serialization;
using Epsitec.Common.Drawing;
using Epsitec.Common.Support;

namespace Epsitec.Common.Document.Objects
{
    /// <summary>
    /// La classe Rectangle est la classe de l'objet graphique "rectangle".
    /// </summary>
    [System.Serializable()]
    public class Rectangle : Objects.Abstract
    {
        public Rectangle(Document document, Objects.Abstract model)
            : base(document, model)
        {
            if (this.document == null)
                return; // objet factice ?
            this.CreateProperties(model, false);
        }

        protected override bool ExistingProperty(Properties.Type type)
        {
            if (type == Properties.Type.Name)
                return true;
            if (type == Properties.Type.LineMode)
                return true;
            if (type == Properties.Type.LineColor)
                return true;
            if (type == Properties.Type.FillGradient)
                return true;
            if (type == Properties.Type.Frame)
                return true;
            if (type == Properties.Type.Corner)
                return true;
            return false;
        }

        protected override Objects.Abstract CreateNewObject(
            Document document,
            Objects.Abstract model
        )
        {
            return new Rectangle(document, model);
        }

        public override void Dispose()
        {
            base.Dispose();
        }

        public override string IconUri
        {
            //	Nom de l'icône.
            get { return Misc.Icon("ObjectRectangle"); }
        }

        public override Polygon PropertyHandleSupport
        {
            //	Retourne le polygone de support pour les poignées des propriétés.
            get
            {
                var polygons = this.GetPolygons();
                return polygons[0];
            }
        }

        public override void MoveHandleStarting(int rank, Point pos, DrawingContext drawingContext)
        {
            //	Début du déplacement d'une poignée.
            base.MoveHandleStarting(rank, pos, drawingContext);

            if (rank < this.handles.Count) // poignée de l'objet ?
            {
                drawingContext.ConstrainClear();

                Handle handle = this.Handle(rank);
                if (handle.PropertyType == Properties.Type.None)
                {
                    if (rank == 0)
                        drawingContext.ConstrainAddRect(
                            this.Handle(0).Position,
                            this.Handle(1).Position,
                            this.Handle(2).Position,
                            this.Handle(3).Position,
                            false,
                            -1
                        );
                    else if (rank == 1)
                        drawingContext.ConstrainAddRect(
                            this.Handle(1).Position,
                            this.Handle(0).Position,
                            this.Handle(3).Position,
                            this.Handle(2).Position,
                            false,
                            -1
                        );
                    else if (rank == 2)
                        drawingContext.ConstrainAddRect(
                            this.Handle(2).Position,
                            this.Handle(3).Position,
                            this.Handle(0).Position,
                            this.Handle(1).Position,
                            false,
                            -1
                        );
                    else if (rank == 3)
                        drawingContext.ConstrainAddRect(
                            this.Handle(3).Position,
                            this.Handle(2).Position,
                            this.Handle(1).Position,
                            this.Handle(0).Position,
                            false,
                            -1
                        );
                }
                else
                {
                    Properties.Abstract property = this.Property(handle.PropertyType);
                    property.MoveHandleStarting(this, handle.PropertyRank, pos, drawingContext);
                }

                drawingContext.MagnetClearStarting();
            }
        }

        public override void MoveHandleProcess(int rank, Point pos, DrawingContext drawingContext)
        {
            //	Déplace une poignée.
            if (rank >= 4) // poignée d'une propriété ?
            {
                base.MoveHandleProcess(rank, pos, drawingContext);
                return;
            }

            this.document.Notifier.NotifyArea(this.BoundingBox);
            drawingContext.SnapPos(ref pos);

            if (rank == 0)
                this.MoveCorner(pos, 0, 2, 3, 1);
            else if (rank == 1)
                this.MoveCorner(pos, 1, 3, 2, 0);
            else if (rank == 2)
                this.MoveCorner(pos, 2, 0, 1, 3);
            else if (rank == 3)
                this.MoveCorner(pos, 3, 1, 0, 2);
            else
                this.Handle(rank).Position = pos;

            this.HandlePropertiesUpdate();
            this.SetDirtyBbox();
            this.TextInfoModifRect();
            this.document.Notifier.NotifyArea(this.BoundingBox);
        }

        public override void CreateMouseDown(Point pos, DrawingContext drawingContext)
        {
            //	Début de la création d'un objet.
            drawingContext.ConstrainClear();
            drawingContext.ConstrainAddHomo(pos, false, -1);
            this.HandleAdd(pos, HandleType.Primary); // rang = 0
            this.HandleAdd(pos, HandleType.Primary); // rang = 1
            this.isCreating = true;
            this.document.Notifier.NotifyArea(this.BoundingBox);
        }

        public override void CreateMouseMove(Point pos, DrawingContext drawingContext)
        {
            //	Déplacement pendant la création d'un objet.
            this.document.Notifier.NotifyArea(this.BoundingBox);
            drawingContext.SnapPos(ref pos);
            this.Handle(1).Position = pos;
            this.SetDirtyBbox();
            this.TextInfoModifRect();
            this.document.Notifier.NotifyArea(this.BoundingBox);
        }

        public override void CreateMouseUp(Point pos, DrawingContext drawingContext)
        {
            //	Fin de la création d'un objet.
            this.document.Notifier.NotifyArea(this.BoundingBox);

            drawingContext.SnapPos(ref pos);
            this.Handle(1).Position = pos;
            drawingContext.ConstrainDelStarting();
            drawingContext.MagnetClearStarting();
            this.isCreating = false;
            this.document.Modifier.TextInfoModif = "";

            //	Crée les 2 autres poignées dans les coins opposés.
            Point p1 = this.Handle(0).Position;
            Point p2 = this.Handle(1).Position;
            this.HandleAdd(new Point(p1.X, p2.Y), HandleType.Primary); // rang = 2
            this.HandleAdd(new Point(p2.X, p1.Y), HandleType.Primary); // rang = 3

            this.HandlePropertiesCreate();
            this.HandlePropertiesUpdate();
            this.document.Notifier.NotifyArea(this.BoundingBox);
        }

        public override bool CreateIsExist(DrawingContext drawingContext)
        {
            //	Indique si l'objet doit exister. Retourne false si l'objet ne peut
            //	pas exister et doit être détruit.
            double len = Point.Distance(this.Handle(0).Position, this.Handle(1).Position);
            return (len > drawingContext.MinimalSize);
        }

        public override void Reset()
        {
            //	Remet l'objet droit et d'équerre.
            if (this.handles.Count >= 4)
            {
                Drawing.Rectangle box = this.BoundingBoxThin;
                this.Handle(0).Position = box.BottomLeft;
                this.Handle(1).Position = box.TopRight;
                this.Handle(2).Position = box.TopLeft;
                this.Handle(3).Position = box.BottomRight;
            }
        }

        public override Shape[] ShapesBuild(
            IPaintPort port,
            DrawingContext drawingContext,
            bool simplify
        )
        {
            //	Constuit les formes de l'objet.
            var frame = this.PropertyFrame;

            Path path = this.PathBuild(drawingContext, simplify);
            var shapes = new List<Shape>();
            var objectShapes = new List<Shape>();

            //	Forme de la surface.
            {
                var shape = new Shape();
                shape.Path = path;
                shape.SetPropertySurface(port, this.PropertyFillGradient);
                objectShapes.Add(shape);
            }

            //	Forme du chemin.
            {
                var shape = new Shape();
                shape.Path = path;
                shape.SetPropertyStroke(port, this.PropertyLineMode, this.PropertyLineColor);
                objectShapes.Add(shape);
            }

            if (!simplify && (frame == null || frame.FrameType == Properties.FrameType.None)) // pas de cadre ?
            {
                shapes.AddRange(objectShapes);
            }
            else // cadre ?
            {
                frame.AddShapes(
                    this,
                    shapes,
                    objectShapes,
                    port,
                    drawingContext,
                    this.GetPolygons(),
                    this.PropertyCorner
                );
            }

            return shapes.ToArray();
        }

        protected Path PathBuild(DrawingContext drawingContext, bool simplify)
        {
            //	Crée le chemin de l'objet.
            var polygons = this.GetPolygons();
            var corner = this.PropertyCorner;
            return Polygon.GetPolygonPathCorner(drawingContext, polygons, corner, simplify);
        }

        protected List<Polygon> GetPolygons()
        {
            var polygons = new List<Polygon>();
            var polygon = new Polygon();
            polygons.Add(polygon);

            if (this.handles.Count < 4)
            {
                var p1 = this.Handle(0).Position;
                var p3 = this.Handle(1).Position;

                polygon.Add(p1);
                polygon.Add(new Point(p1.X, p3.Y));
                polygon.Add(p3);
                polygon.Add(new Point(p3.X, p1.Y));
            }
            else
            {
                polygon.Add(this.Handle(0).Position);
                polygon.Add(this.Handle(2).Position);
                polygon.Add(this.Handle(1).Position);
                polygon.Add(this.Handle(3).Position);
            }

            return polygons;
        }

        public override Path GetMagnetPath()
        {
            //	Retourne le chemin géométrique de l'objet pour les constructions
            //	magnétiques.
            return this.PathBuild(null, true);
        }

        protected override Path GetPath()
        {
            //	Retourne le chemin géométrique de l'objet.
            return this.PathBuild(null, false);
        }

        #region Serialization
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            //	Sérialise l'objet.
            base.GetObjectData(info, context);
        }

        protected Rectangle(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            //	Constructeur qui désérialise l'objet.
        }
        #endregion
    }
}
